#+title: Emacs literate configuration
#+author: Wanderson Ferreira
#+EMAIL: wanderson.ferreira@protonmail.com
#+date: 2020:04:02

Literate Emacs configuration style. This is part of my journey for
/Teach myself programming in 10 years/. I'm using this configuration
on a system running [[https://wiki.archlinux.org/][Arch Linux]] and Emacs 26.3, that's why this
configuration will be using the latest features and /not check/ for
the system it's running on.

Every emacs user should write his own configuration file and steal as
many code as he wants from here (or elsewhere).

#+BEGIN_SRC emacs-lisp
  (unless (equal user-login-name "wand")
    (warn "Please don't load Wand init file, it probably won't work for you.")
    (with-current-buffer " *load*"
      (goto-char (point-max))))
#+END_SRC

* Summary                                                               :TOC:
- [[#packages][Packages]]
- [[#dependencies][Dependencies]]
  - [[#extra][Extra]]
    - [[#dunst][dunst]]
    - [[#scrot][scrot]]
    - [[#screensavers][screensavers]]
  - [[#browsers][Browsers]]
    - [[#qutebrowser][Qutebrowser]]
    - [[#google-chrome][Google Chrome]]
- [[#operating-system][Operating System]]
  - [[#async][Async]]
  - [[#path][PATH]]
  - [[#security][Security]]
  - [[#garbage-collection][Garbage Collection]]
  - [[#manage-external-services][Manage external services]]
- [[#aesthetics][Aesthetics]]
  - [[#cleaning][Cleaning]]
  - [[#theme-and-faces][Theme and Faces]]
  - [[#time][Time]]
  - [[#font][Font]]
  - [[#fringe][Fringe]]
- [[#defaults][Defaults]]
  - [[#recentf][Recentf]]
  - [[#uniquify][Uniquify]]
  - [[#extended-command][Extended Command]]
  - [[#case-switch][Case switch]]
  - [[#registers][Registers]]
  - [[#abbreviation][Abbreviation]]
  - [[#imenu][Imenu]]
  - [[#ibuffer][Ibuffer]]
  - [[#minibuffer][Minibuffer]]
  - [[#help][Help]]
  - [[#calendar][Calendar]]
  - [[#webjump][Webjump]]
  - [[#authentication-source][Authentication Source]]
- [[#help-1][Help]]
- [[#editing-text][Editing Text]]
  - [[#defaults-1][Defaults]]
    - [[#very-large-files][Very large files]]
    - [[#eldoc][Eldoc]]
    - [[#subword][Subword]]
  - [[#extra-features][Extra Features]]
    - [[#smart-shift][Smart shift]]
    - [[#change-inner][Change inner]]
    - [[#expand-region][Expand region]]
    - [[#jump-to-char][Jump to char]]
  - [[#highlights][Highlights]]
  - [[#utf-8][UTF-8]]
  - [[#multiple-cursors][Multiple Cursors]]
  - [[#custom-functions][Custom functions]]
    - [[#smart-move-to-beginning-of-visible-line-or-not][Smart move to beginning of visible line (or not)]]
    - [[#unfill-paragraph][Unfill paragraph]]
    - [[#duplicate-line-or-region][Duplicate line or region]]
  - [[#hide-block-of-code][Hide block of code]]
- [[#completions][Completions]]
  - [[#minibuffer-ido-mode][Minibuffer (ido mode)]]
  - [[#company-mode][Company mode]]
  - [[#hippie-expand][Hippie Expand]]
- [[#window][Window]]
  - [[#winner][Winner]]
- [[#dired][Dired]]
  - [[#guidelines][Guidelines]]
    - [[#mark-files-in-dired][Mark files in Dired]]
    - [[#replace-text-in-multiple-files][Replace text in multiple files]]
  - [[#ranger][Ranger]]
  - [[#functions][Functions]]
- [[#tramp][TRAMP]]
- [[#version-control][Version Control]]
  - [[#magit][Magit]]
    - [[#gitconfig][Gitconfig]]
    - [[#gitignore][Gitignore]]
  - [[#time-machine][Time machine]]
  - [[#visual-identification][Visual identification]]
  - [[#miscellaneous][Miscellaneous]]
- [[#search][Search]]
  - [[#wgrep][Wgrep]]
  - [[#ripgrep][Ripgrep]]
  - [[#isearch][Isearch]]
  - [[#occur][Occur]]
- [[#shell][Shell]]
- [[#general-programming][General Programming]]
  - [[#whitespaces][Whitespaces]]
  - [[#clojure][Clojure]]
  - [[#python][Python]]
  - [[#sql][SQL]]
  - [[#latex][Latex]]
  - [[#linters][Linters]]
  - [[#unified-modeling-language][Unified Modeling Language]]
  - [[#parenthesis][Parenthesis]]
- [[#additional-major-modes][Additional Major Modes]]
  - [[#rest-client][Rest client]]
  - [[#markdown][Markdown]]
  - [[#json][Json]]
  - [[#yaml][Yaml]]
  - [[#makefile][Makefile]]
- [[#notes][Notes]]
- [[#pdf][PDF]]
- [[#org-mode][Org mode]]
  - [[#defaults-2][Defaults]]
    - [[#manipulating-sections][Manipulating Sections]]
    - [[#seamless-navigation-between-source-blocks][Seamless Navigation Between Source Blocks]]
  - [[#table-of-contents][Table of Contents]]
  - [[#capture][Capture]]
  - [[#structure-templates][Structure Templates]]
  - [[#revealjs][Reveal.js]]
    - [[#more-details-from-how-to-build-one-presentation-using-the-package][More details from how to build one presentation using the package]]
- [[#projects][Projects]]
- [[#spelling][Spelling]]
  - [[#correct-your-spelling-errors-on-the-fly][Correct your spelling errors on the fly]]
  - [[#using-a-grammar--style-checker][Using a Grammar & Style Checker]]
  - [[#synonyms][Synonyms]]
  - [[#translate][Translate]]
  - [[#typing][Typing]]
- [[#snippets][Snippets]]
- [[#docker][Docker]]
- [[#spotify][Spotify]]
- [[#rss-feed][RSS Feed]]
- [[#slack][Slack]]
- [[#telegram][Telegram]]
- [[#pomodoro][Pomodoro]]
- [[#advice][Advice]]
  - [[#pop-to-mark][Pop to mark]]
  - [[#yank-indent][Yank indent]]
- [[#general-custom-functions][General custom functions]]
  - [[#http-based][HTTP-based]]
    - [[#find-my-current-ip][Find my current IP]]
  - [[#editing][Editing]]
    - [[#what-sudo][what? sudo!]]
    - [[#eval-and-replace][eval and replace]]
  - [[#buffer][Buffer]]
    - [[#kill-buffer-and-the-file-associated][Kill buffer and the file associated]]
- [[#keys][Keys]]
  - [[#hint][Hint]]
  - [[#global-definitions][Global definitions]]
  - [[#cast][Cast]]
- [[#emacs-as-my-own-operating-system][Emacs as my own Operating System]]
  - [[#multiple-screens][Multiple Screens]]
  - [[#system-package][System package]]
  - [[#notification-daemon][Notification Daemon]]
  - [[#window-behaviour][Window behaviour]]
  - [[#key-bindings][Key Bindings]]
  - [[#important-commands][Important commands]]
- [[#references][References]]

* Packages

  Emacs facility to download and install "packages" that implement
  additional features. You can find information about a specific
  package by using =C-h P= that prompts for the name and shows more
  details.

  There is a very detail package in Emacs help system that you can
  find on [[info:emacs#Packages][info:emacs#Packages]].

  I always start a new configuration setup with a naive mindset that I
  will not install thousands of external packages, however they are so
  good and make our life so much easier that is hard to avoid them
  altogether.

  Let's initialize the package system.
  #+begin_src emacs-lisp
     (require 'package)

     (unless (bound-and-true-p package--initialized)
       (package-initialize))
  #+end_src

  Despite the fact that GNU Elpa, the standard repository, of Emacs
  packages maintained by the core team already have many different
  packages, I like to use another external repository called [[https://melpa.org/#/][Melpa]] which
  is currently maintained by the community and curated by Purcell's and
  his team.

  #+begin_src emacs-lisp
     (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  #+end_src

  We need to refresh the archives to make this change to take place.

  #+begin_src emacs-lisp
     (unless (file-exists-p "~/.emacs.d/elpa/archives/melpa")
       (package-refresh-contents))
  #+end_src

  Also, by default Emacs also automatically loads all installed packages
  in subsequent Emacs session. I want to disable it.

  #+begin_src emacs-lisp
    (setq package-enable-at-startup nil)
  #+end_src

  When you have more than a dozen packages, it makes the process of
  managing them very difficult without any additional help. And by my
  experience the only real issue is due to performance because you
  will inevitably have many external packages loaded in situations
  where you don't need it. Fortunately, Jon Wiegley made our lives
  easier by creating =use-package=, please look for =C-h P
  use-package= to more details.

  #+begin_src emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package)
       (package-install 'delight))

     (require 'use-package)
  #+end_src

  We can add new keywords to =use-package=, stolen from [[https://github.com/xuchunyang/emacs.d/blob/master/init.el][here.]]
  #+BEGIN_SRC emacs-lisp
    (defmacro bk-use-package-keywords-add (keyword)
      "Add new keyword as placeholder"
      `(progn
         (add-to-list 'use-package-keywords ,keyword 'append)
         (defun ,(intern (format "use-package-normalize/%s" keyword)) (&rest _))
         (defun ,(intern (format "use-package-handler/%s" keyword)) (&rest _))))

    (bk-use-package-keywords-add :about)
    (bk-use-package-keywords-add :homepage)
  #+END_SRC

  Some old packages simply are not in any repository, they are only
  elisp files distributed over the web. I will place these files
  inside a folder called =lisps=.

  #+BEGIN_SRC emacs-lisp
    (setq site-lisps-dir (expand-file-name "lisps" user-emacs-directory))

    (dolist (project (directory-files site-lisps-dir t "\\w+"))
      (when (file-directory-p project)
        (add-to-list 'load-path project)))
  #+END_SRC

* Dependencies

  List of external packages that I rely on in my daily basis

** Extra
*** dunst
*** scrot
*** screensavers

    I use the external package called =xscreensaver= which is amazing.
    You can lock the screen by pressing =s-l= or calling =M-x
    bk/lock-screen=.

    Emacs zone is also an happy surprise for me. It seems like this is
    a default mode to 'zones' Emacs out by choosing one of its random
    modes to obfuscate the current buffer, which can then be used as a
    screensaver.

    I will add some configuration for this.
    #+BEGIN_SRC emacs-lisp

      (use-package zone
        :ensure nil
        :config
        (defvar zone--window-config nil)
        (defadvice zone (before zone-ad-clean-ui)
          "Maximize window before `zone' starts."
          (setq zone--window-config (current-window-configuration))
          (delete-other-windows)
          (when (and (eq window-system 'x) (executable-find "xtrlock"))
            (start-process "xtrlock" nil "xtrlock")))
        (defadvice zone (after zone-ad-restore-ui)
          "Restore window configuration."
          (when zone--window-config
            (set-window-configuration zone--window-config)
            (setq zone--window-config nil)))
        (ad-activate 'zone))
    #+END_SRC

    I also installed =xtrlock= so when I activate =zone= I also lock
    my screen. In order to unlock you just need to start typing the
    correct password and press =RET=.

** Browsers
*** Qutebrowser

    A keyboard-driven, vim-like browser based on PyQt5 [[https://www.qutebrowser.org/][web browser]] with
    a minimal GUI.

    I met this project back at the university in 2012 and is hard to
    remember but I think it was the first time that I talked to other
    programmers online with attempts to report bugs and errors for the
    maintainers of this browser. Very nice project.

    The [[https://raw.githubusercontent.com/qutebrowser/qutebrowser/master/doc/img/cheatsheet-big.png][cheat sheet]] is very important.

    The following file is not my complete =config.py= file for
    qutebrowser, only the diff from defaults. If you want to create a
    default config file, you should use =:config-write-py --default=.

    #+BEGIN_SRC conf
      # Always restore open sites when qutebrowser is reopened.
      # Type: Bool
      c.auto_save.session = False

      # Show javascript alerts
      # Type: Bool
      c.content.javascript.alert = False

      # Allow websites to record audio/video
      c.content.media_capture = 'ask'

      # Allow websites to lock your mouse
      c.content.mouse_lock = True

      # Allow websites to show notifications
      c.content.notifications = False

      ## Open a new window for every tab.
      ## Type: Bool
      c.tabs.tabs_are_windows = True
    #+END_SRC

*** Google Chrome

    You know, that time when the internet tells you: "you can't see
    this page without a google-based product today"
* Operating System

** Async

  Asynchronous bytecode compilation and various other actions makes
  Emacs look SIGNIFICANTLY less often which is a good thing.
  #+BEGIN_SRC emacs-lisp
    (use-package async
      :ensure t
      :defer t
      :init
      (dired-async-mode 1)
      (async-bytecomp-package-mode 1)
      :custom (async-bytecomp-allowed-packages '(all)))
  #+END_SRC

** PATH

   #+begin_src emacs-lisp
     (setenv "PATH" (concat (getenv "PATH") ":/home/wand/scripts"))
     (setq exec-path (append exec-path '("/home/wand/scripts")))

     (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
     (setq exec-path (append exec-path '("/usr/local/bin")))

     (setenv "LD_LIBRARY_PATH" (concat (getenv "LD_LIBRARY_PATH") ":/usr/local/lib"))
     (setq exec-path (append exec-path '("/usr/local/lib")))

   #+end_src

   I've been using qutebrowser as my main browser for more than one year
   now. Idk, I like keyboard centric products.
   #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'browse-url-generic
   	browse-url-generic-program "qutebrowser")
   #+END_SRC

** Security

   Fix old security Emacs problems
   #+BEGIN_SRC emacs-lisp
     (eval-after-load "enriched"
       '(defun enriched-decode-display-prop (start end &optional param)
          (list start end)))
   #+END_SRC

** Garbage Collection

   Garbage collection shouldn't happen during startup, as what will
   slow Emacs down. Do it later.

   Ease the font caching during GC.
   #+begin_src emacs-lisp
     (setq inhibit-compacting-font-caches t)
   #+end_src

   Emacs can inform us when the garbage collection is happening.
   #+BEGIN_SRC emacs-lisp
     (setq garbage-collection-messages t)
   #+END_SRC

** Manage external services

   Very interesting package that help us to have some instances of
   external processes running and keep track of it all. I often need
   to enable the VPN of my company to work remotely, this suits
   nicely.

   #+BEGIN_SRC emacs-lisp
     (use-package prodigy
       :ensure t
       :config
       (prodigy-define-service
         :name "Captalys VPN"
         :command "captalys-vpn"
         :tags '(captalys)
         :stop-signal 'sigkill
         :kill-process-buffer-on-stop t)

       (prodigy-define-service
         :name "Blog"
         :command "lein ring server"
         :cwd "~/bartuka-blog"
         :stop-signal 'sigkill
         :tags '(blog)
         :kill-process-buffer-on-stop t)

       (prodigy-define-tag
         :name 'captalys
         :ready-message "Initialization Sequence Completed")
       (prodigy-define-tag
         :name 'blog
         :ready-message "Started server on port 3000"))
   #+END_SRC

* Aesthetics

** Cleaning

    Since I never use the mouse with GNU Emacs, I prefer not to use
    invasive graphical elements.
    #+begin_src emacs-lisp
      (when window-system
        (menu-bar-mode -1)
        (tool-bar-mode -1)
        (scroll-bar-mode -1))
    #+end_src

    Emacs convention is to show help and other inline documentation in
    the message area. Show help there instead of OS tooltip.
    #+BEGIN_SRC emacs-lisp
      (when (display-graphic-p)
        (tooltip-mode -1))
    #+END_SRC

    Let's remove some crunchy messages at startup time.
    #+begin_src emacs-lisp
      (setq inhibit-splash-screen t
            inhibit-startup-echo-area-message t)
    #+end_src

    Enabling some builtin modes that are very helpful e.g. highlight
    the positions of open/close of parenthesis, prettify symbols for
    now basically converts a fn to a lambda symbol, but I intend to
    expand the list of converted symbols.

    #+begin_src emacs-lisp
      (show-paren-mode t)
      (global-prettify-symbols-mode t)
      (blink-cursor-mode 0)
    #+end_src

    #+begin_src emacs-lisp
      (use-package simple
        :ensure nil
        :delight auto-fill-mode
        :config
        (add-hook 'text-mode-hook #'auto-fill-mode))
    #+end_src

** Theme and Faces

    The color theme is always a complicated matter. I've been trying
    several ones, most recently I had settle with Protesilaos
    =modus-{operandi,vivendi}= packages, but now I want to try =dakrone=
    for a while. =deprecated= already. I will be using the default
    white one.

    Find out what face something at point have.
    #+BEGIN_SRC emacs-lisp
      (defun what-face (pos)
        (interactive "d")
        (let ((face (or (get-char-property (point) 'read-face-name)
                        (get-char-property (point) 'face))))
          (if face (message "Face: %s" face) (message "No face at %d" pos))))
    #+END_SRC

    Change the highlight color for selection text.
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'region nil :background "#666")
    #+END_SRC

    Make cursor the width of the character it is under.
    #+BEGIN_SRC emacs-lisp
      (setq x-stretch-cursor t)
    #+END_SRC
** Time

   #+BEGIN_SRC emacs-lisp
     (use-package time
       :ensure nil
       :init
       (setq display-time-default-load-average nil
	     display-time-format "%Hh%M "
	     display-time-day-and-date t)
       :config
       (display-time-mode t))
   #+END_SRC

** Font

    I like the default font, but why not change it towards a more
    programming-friendlier one: Source Code Pro.

    #+begin_src emacs-lisp
      (defun bk/font-family-size (family size)
        "Set frame font to FAMILY at SIZE."
        (set-frame-font
         (concat family "-" (number-to-string size) ":hintstyle=hintfull") t t))

      ;; the default for a while again...
      ;; (bk/font-family-size "Source Code Pro Medium" 12)
    #+end_src

** Fringe

    Control the fringe around the frame.
    #+BEGIN_SRC emacs-lisp
      (fringe-mode '(10 . 1))
    #+END_SRC

    Preview line numbers when prompting for line number.
    #+BEGIN_SRC emacs-lisp
      (define-advice goto-line (:before (&rest _) preview-line-number)
        "Preview line number when prompting for goto-line."
        (interactive
         (lambda (spec)
           (if (and (boundp 'display-line-numbers)
                    (not display-line-numbers))
               (unwind-protect
                   (progn (display-line-numbers-mode)
                          (advice-eval-interactive-spec spec))
                 (display-line-numbers-mode -1))
             (advice-eval-interactive-spec spec)))))
    #+END_SRC

* Defaults

  I ran into this little tidbit while reading Sacha Chu'a posts from
  Emacs. You can find the whole discussion [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][here]] but the idea is that
  =next-line= defun triggers =line-move-partial= which leads to
  excessive processing. By setting the variable below, the speed of
  using =next-line= gets very cut down.
  #+BEGIN_SRC emacs-lisp
    (setq auto-window-vscroll nil)
  #+END_SRC

  Do not clutter my =init.el= file with customized variables.
  #+begin_src emacs-lisp
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (when (file-exists-p custom-file)
      (load custom-file))
  #+end_src

  Show current key-sequence in minibuffer, like vim does. Any feedback
  after typing is better UX than no feedback at all.
  #+BEGIN_SRC emacs-lisp
    (setq echo-keystrokes 0.2)
  #+END_SRC

  Allow pasting selection outside of Emacs
  #+BEGIN_SRC emacs-lisp
    (setq x-select-enable-clipboard t)
  #+END_SRC

  Say you copied a link from your web browser, then switched to Emacs to
  paste it somewhere. Before you do that, you notice something you want
  to kill. Doing that will place the last kill to the clipboard, thus
  overriding the thing you copied earlier. We can have a kill ring
  solution:
  #+BEGIN_SRC emacs-lisp
    (setq save-interprogram-paste-before-kill t)
  #+END_SRC

  #+begin_src emacs-lisp
    (setq tab-always-indent 'complete)
    (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
    (setq custom-safe-themes t)

    (defalias 'cquit 'cider-quit)
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; built in htop
    (setq proced-auto-update-flag t
  	proced-auto-update-interval 1
  	proced-descend t)
  #+end_src

  #+BEGIN_SRC emacs-lisp
    ;; A saner ediff
    (setq ediff-diff-options "-w")
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  #+END_SRC

  Don’t use tabs to indent and fix some indentation settings
  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil
                  tab-width 4
                  fill-column 70)
  #+END_SRC

  Word wrapping
  #+BEGIN_SRC emacs-lisp
    (setq-default word-wrap t
                  truncate-lines t
                  truncate-partial-width-windows nil
                  sentence-end-double-space nil
                  delete-trailing-lines nil
                  require-final-newline t
                  tabify-regexp "^\t* [ \t]+")
  #+END_SRC

  Favor hard-wrapping in text modes
  #+BEGIN_SRC emacs-lisp
    (defun bk/auto-fill ()
      "My autofill setup for text buffers."
      (auto-fill-mode t)
      (delight 'auto-fill-mode))

    (add-hook 'text-mode-hook #'bk/auto-fill)

  #+END_SRC

  Enable some built in modes to add critical functionality to
  Emacs. More explanation about them will follow in future.

  #+begin_src emacs-lisp
    (delete-selection-mode t)
    (pending-delete-mode t)
    (column-number-mode 1)
    (global-auto-revert-mode)

    ;; real emacs knights don't use shift to mark things
    (setq shift-select-mode nil)
  #+end_src

** Recentf

   This is a built-in mode that keeps track of the files you have
   opened allowing you go back to them faster. It can also integrate
   with a completion framework to populate a =virtual buffers= list.

   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :ensure nil
       :init
       (setq recentf-max-saved-items 50
	     recentf-max-menu-items 15
	     recentf-show-file-shortcuts-flag nil
	     recentf-auto-cleanup 'never)
       :config
       (recentf-mode t))
   #+END_SRC

** Uniquify

   Uniquify buffer names dependent on file name. Emacs's traditional
   method for making buffer names unique adds <2>, <3>, etc to the end
   of (all but one of) the buffers. This settings change the default
   behavior.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :ensure nil
       :config
       (setq uniquify-buffer-name-style 'post-forward-angle-brackets
	     uniquify-separator " * "
	     uniquify-after-kill-buffer-p t
	     uniquify-strip-common-suffix t
	     uniquify-ignore-buffers-re "^\\*"))
   #+END_SRC
** Extended Command

=smex= is an improved version of =extended-command= or =M-x=

#+begin_src emacs-lisp
  (use-package smex
    :ensure t
    :config
    (smex-initialize))
#+end_src

** Case switch

#+begin_src emacs-lisp
  (use-package fix-word
    :ensure t
    :config
    (global-set-key (kbd "M-u") #'fix-word-upcase)
    (global-set-key (kbd "M-l") #'fix-word-downcase)
    (global-set-key (kbd "M-c") #'fix-word-capitalize))
#+end_src

** Registers

Emacs registers are compartments where you can save text, rectangles,
positions, and other things for later use. Once you save text or a
rectangle in a register, you can copy it into the buffer once or many
times; once you save a position in a register, you can jump back to
that position once or many times.

For more information: `C-h r' and then letter *i* to search for
registers and the amazing video from [[https://youtu.be/u1YoF4ycLTY][Protesilaos]].

The prefix to all commands of registers is *C-x r*


| command             | description                         |
|---------------------+-------------------------------------|
| M-x view-register R | see what register R contains        |
| C-x r s             | save region to register             |
| C-x r i             | insert text from a register         |
| C-x r n             | record a number defaults to 0       |
| C-x r +             | increment a number from register    |
| C-x r SPC           | record a position into register     |
| C-x r j             | jump to positions or windows config |
| C-x r w             | save a window configuration         |
| C-x r f             | save a frame configuration          |


Important note: the data saved into the register is persistent as long
as you don't override it.

The way to specify a number, is to use an universal argument e.g.
*C-u <number> C-x n*


Clean all the registers you saved.
#+BEGIN_SRC emacs-lisp
  (defun bk/clear-registers ()
    "Remove all saved registers."
    (interactive)
    (setq register-alist nil))
#+END_SRC


#+begin_src emacs-lisp
  (set-register ?e '(file . "~/.emacs.d/init.el"))
  (set-register ?t '(file . "~/org/todo.org"))
  (set-register ?c '(file . "~/.emacs.d/docs/cheatsheet.org"))

#+end_src

** Abbreviation

#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :delight abbrev-mode
    :config
    (setq-default abbrev-mode t))

  (defun bk/add-region-local-abbrev (start end)
    "Go from START to END and add the selected text to a local abbrev."
    (interactive "r")
    (if (use-region-p)
	(let ((num-words (count-words-region start end)))
	  (add-mode-abbrev num-words)
	  (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a l") 'bk/add-region-local-abbrev)

  (defun bk/add-region-global-abbrev (start end)
    "Go from START to END and add the selected text to global abbrev."
    (interactive "r")
    (if (use-region-p)
	(let ((num-words (count-words-region start end)))
	  (add-abbrev global-abbrev-table "Global" num-words)
	  (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a g") 'bk/add-region-global-abbrev)
#+end_src

** Imenu

#+begin_src emacs-lisp
    ;;; imenu - produces menus for accessing locations in documents
  ;; for source-code buffer the locations to index are typically definitions
  ;; of functions, variables, and so on.
  (require 'imenu)

  (defun ido-menu--read (index-alist &optional prompt)
    "Show imenu INDEX-ALIST on ido interface as PROMPT."
    (let* ((symatpt (thing-at-point 'symbol))
       (names (mapcar 'car index-alist))
       (name (ido-completing-read (or prompt "imenu ") names
                      nil t nil nil nil))
       (choice (assoc name index-alist)))
      (if (imenu--subalist-p choice)
      (ido-menu--read (cdr choice) prompt nil)
    choice)))

  (defun bk/ido-menu ()
    "Public interface to my custom imenu through ido."
    (interactive)
    (let ((index-alist (cdr (imenu--make-index-alist))))
      (if (equal index-alist '(nil))
      (message "No imenu tags in buffer")
    (imenu (ido-menu--read index-alist nil)))))

  (global-set-key (kbd "C-.") 'bk/ido-menu)

#+end_src

** Ibuffer

   It provides a way of filtering and then grouping the list of
   buffers that you currently have open. About the configuration
   below:

   | Default           | Explanation                                                |
   |-------------------+------------------------------------------------------------|
   | ibuffer-expert    | Stop asking for confirmation after every action in Ibuffer |
   | ibyffer-auto-mode | Keeps the buffer list up to date                           |

   #+begin_src emacs-lisp

     (use-package ibuffer
       :ensure nil
       :init
       (setq ibuffer-expert t)
       (setq ibuffer-show-empty-filter-groups nil)
       (setq ibuffer-saved-filter-groups
	  '(("Main"
	     ("Directories" (mode . dired-mode))
	     ("Rest" (mode . restclient-mode))
	     ("Docker" (or
			(mode . docker-compose-mode)
			(mode . dockerfile-mode)))
	     ("Programming" (or
			     (mode . clojure-mode)
			     (mode . emacs-lisp-mode)
			     (mode . python-mode)))
	     ("Browser" (or
			 (name . "qutebrowser:\*")
			 ))
	     ("Org" (mode . org-mode))
	     ("Markdown" (or
			  (mode . markdown-mode)
			  (mode . gfm-mode)))
	     ("Git" (or
		     (mode . magit-blame-mode)
		     (mode . magit-cherry-mode)
		     (mode . magit-diff-mode)
		     (mode . magit-log-mode)
		     (mode . magit-process-mode)
		     (mode . magit-status-mode)))
	     ("Emacs" (or
		       (name . "^\\*Help\\*$")
		       (name . "^\\*Custom.*")
		       (name . "^\\*Org Agenda\\*$")
		       (name . "^\\*info\\*$")
		       (name . "^\\*scratch\\*$")
		       (name . "^\\*Backtrace\\*$")
		       (name . "^\\*Messages\\*$"))))))
       :config
       (add-hook 'ibuffer-mode-hook
		 (lambda ()
		   (ibuffer-auto-mode 1)
		   (ibuffer-switch-to-saved-filter-groups "Main"))))
   #+end_src

   Package =ibuffer-vc= let you filter the Ibuffer by projects
   definitions (in my case, every folder that has a =.git= folder
   inside is considered a project).

   #+BEGIN_SRC emacs-lisp
     (use-package ibuffer-vc
       :ensure t
       :after ibuffer
       :config
       (define-key ibuffer-mode-map (kbd "/ V") 'ibuffer-vc-set-filter-groups-by-vc-root))
   #+END_SRC

   Increasing the width of each column in ibuffer. Some buffers names
   are very large in EXWM.

   #+BEGIN_SRC emacs-lisp
     (setq ibuffer-formats
	   '((mark modified read-only " "
		   (name 60 60 :left :elide) ; change: 60s were originally 18s
		   " "
		   (size 9 -1 :right)
		   " "
		   (mode 16 16 :left :elide)
		   " " filename-and-process)
	     (mark " "
		   (name 16 -1)
		   " " filename)))
   #+END_SRC

   #+RESULTS:

** Minibuffer

   The following setting prevent the minibuffer to grow, therefore it
   will be always 1 line height.

   #+begin_src emacs-lisp
     (setq resize-mini-windows nil)
     (setq max-mini-window-height 1)
   #+end_src

** Help
** Calendar

   #+BEGIN_SRC emacs-lisp
     (use-package calendar
       :ensure nil
       :hook (calendar-today-visible . calendar-mark-today)
       :config
       (setq calendar-latitude -23.5475
             calendar-longitude -46.63611
             calendar-location-name "Sao_Paulo, Brazil")
       (setq calendar-holiday-marker t))
   #+END_SRC

** Webjump

Provide a nice keyboard interface to web pages of your choosing.

Adding urban dictionary to webjump.
#+BEGIN_SRC emacs-lisp
  (eval-after-load "webjump"
    '(add-to-list 'webjump-sites '("Urban Dictionary" . [simple-query
							 "www.urbandictionary.com"
							 "http://www.urbandictionary.com/define.php?term="
							 ""])))

  (global-set-key (kbd "C-c j") 'webjump)
#+END_SRC

** Authentication Source

   Auth Source is a generic interface for common backends such as your
   operating sysetm's keychain and your local ~/.authinfo file. Auth
   Source solves the problem of mapping passwords and usernames to hosts.

   Debugging auth issues
   #+BEGIN_SRC emacs-lisp
     (setq auth-source-debug t)
   #+END_SRC

   We need to tell auth-source where to look for secrets.
   #+BEGIN_SRC emacs-lisp
     (setq auth-sources '((:source "~/.emacs.d/secrets/.authinfo")))
   #+END_SRC

   GPG

   #+BEGIN_SRC emacs-lisp
     (use-package pinentry :ensure t)
     (use-package epa
       :ensure nil
       :config
       (setq epa-pinentry-mode 'loopback)
       (pinentry-start))
   #+END_SRC

* Help

  Is good to know how to ask for help in Emacs
  #+BEGIN_SRC emacs-lisp
    (use-package helpful
      :ensure t
      :bind
      (("C-h f" . helpful-callable)
       ("C-h v" . helpful-variable)
       ("C-h k" . helpful-key)
       ("C-h ," . helpful-at-point)))
  #+END_SRC
* Editing Text

** Defaults

   See also =bidi-paragraph-direction=; setting that non-nil might
   speed up redisplay.
   #+BEGIN_SRC emacs-lisp
     (setq bidi-paragraph-direction 'left-to-right)
   #+END_SRC

*** Very large files

    Since I am using EXWM, I might open very large files, there is a
    package to help Emacs handle this kind of files.

    #+BEGIN_SRC emacs-lisp
      (use-package vlf
        :ensure t
        :defer t)
    #+END_SRC

    I found a good paper about =log files= in Emacs where they mention
    =vlf= package. This [[https://writequit.org/articles/working-with-logs-in-emacs.html][paper]] is very worth reading nevertheless.

*** Eldoc
   #+begin_src emacs-lisp
     (use-package eldoc
       :ensure nil
       :delight eldoc-mode
       :init
       (setq eldoc-idle-delay 0.1
             eldoc-echo-area-use-multiline-p nil)
       (eldoc-mode 1)
       :config
       (add-hook 'prog-mode-hook 'turn-on-eldoc-mode))
   #+end_src

*** Subword

    #+BEGIN_SRC emacs-lisp
      (use-package subword
        :ensure nil
        :delight subword-mode)
    #+END_SRC

** Extra Features

*** Smart shift
   #+begin_src emacs-lisp
     (use-package smart-shift
       :homepage https://github.com/hbin/smart-shift
       :about Shift the line/region to the left/right by the current major mode indentation
       :ensure t
       :config
       (global-smart-shift-mode t))
   #+end_src

*** Change inner

   #+begin_src emacs-lisp
     (use-package change-inner
       :homepage https://github.com/magnars/change-inner.el
       :about vim's `ci' command, building on expand-region
       :ensure t)
   #+end_src

*** Expand region
   #+begin_src emacs-lisp
     (use-package expand-region
       :homepage https://github.com/magnars/expand-region.el
       :about Extension to increase selected region by semantic units
       :ensure t)
   #+end_src

*** Jump to char

   #+begin_src emacs-lisp
     (use-package avy
       :homepage https://github.com/abo-abo/avy
       :about Jump to things in Emacs tree-style
       :ensure t
       :config
       (avy-setup-default)
       (global-set-key (kbd "C-c ;") 'avy-goto-char))
   #+end_src

** Highlights

   Visual feedback on some operations like yank, kill, undo. An
   example is that if you paste the next key. This is just a small
   tweak, but gives a nice bit of visual feedback.

   #+BEGIN_SRC emacs-lisp
     (use-package volatile-highlights
       :ensure t
       :delight volatile-highlights-mode
       :defer t
       :config
       (volatile-highlights-mode t))
   #+END_SRC

   Very often is useful to highlight some symbols.
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :hook
       ((highlight-symbol-mode . highlight-symbol-nav-mode)
        (prog-mode . highlight-symbol-mode))
       :custom
       (highlight-symbol-highlight-single-occurrence nil)
       (highlight-symbol-idle-delay 0.25)
       (highlight-symbol-on-navigation-p t))
   #+END_SRC

** UTF-8

   No one knows why this is not the default already.

   #+BEGIN_SRC emacs-lisp
     (prefer-coding-system 'utf-8)
     (setq locale-coding-system 'utf-8)
     (set-language-environment "UTF-8")
     (set-default-coding-systems 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
   #+END_SRC

** Multiple Cursors

   [[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] is a very nice package that lets you create
   several cursors that all do the same thing as you type.

   #+begin_src emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind
       (("C->" . mc/mark-next-like-this)
        ("C-<" . mc/mark-previous-like-this)
        ("C-S-<mouse-1>" . mc/add-cursor-on-click)
        ("C-c m c" . mc/edit-lines)))
   #+end_src

   To use =mc/edit-lines= you need to highlight the lines on which you
   wish to have cursors and use =C-c m c=. Now you can edit away and
   press enter when you are done to exit multiple cursors.

   There is this amazing [[http://emacsrocks.com/e13.html][video]] from magnars showing off multiple
   cursors features.

   However, occasionally the best way to get the cursors where you
   want them is with the mouse. With the following code, =C-S-<left
   mouse click>= adds a new cursor.
** Custom functions

   Several helper functions to ease the day-to-day work of editing
   text.

*** Smart move to beginning of visible line (or not)

    Very nice default.

    #+begin_src emacs-lisp
      ;; `C-a' first takes you to the first non-whitespace char as
      ;; `back-to-indentation' on a line, and if pressed again takes you to
      ;; the actual beginning of the line.
      (defun smarter-move-beginning-of-line (arg)
        "Move depending on ARG to beginning of visible line or not.
        From https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/."
        (interactive "^p")
        (setq arg (or arg 1))
        (when (/= arg 1)
          (let ((line-move-visual nil))
    	(forward-line (1- arg))))
        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
    	(move-beginning-of-line 1))))

      (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
    #+end_src

*** Unfill paragraph

    I used it sometimes when yanking text written in Emacs to paste in
    other external apps such as gmail and I don't want the "break
    line" to be at 70th column there.

    #+BEGIN_SRC emacs-lisp
      (defun unfill-paragraph ()
        "Takes a multi-line paragraph and makes it into a single line of text."
        (interactive)
        (let ((fill-column (point-max)))
          (fill-paragraph nil)))
    #+END_SRC

*** Duplicate line or region

    #+BEGIN_SRC emacs-lisp
      (defun duplicate-current-line-or-region (arg)
        "Duplicates the current line or region ARG times.
      If there's no region, the current line will be duplicated."
        (interactive "p")
        (save-excursion
          (if (region-active-p)
              (duplicate-region arg)
            (duplicate-current-line arg))))

      (defun duplicate-region (num &optional start end)
        "Duplicates the region bounded by START and END NUM times.
      If no START and END is provided, the current region-beginning
      region-end is used."
        (interactive "p")
        (let* ((start (or start (region-beginning)))
               (end (or end (region-end)))
               (region (buffer-substring start end)))
          (goto-char start)
          (dotimes (i num)
            (insert region))))

      (defun duplicate-current-line (num)
        "Duplicate the current line NUM times."
        (interactive "p")
        (when (eq (point-at-eol) (point-max))
          (goto-char (point-max))
          (newline)
          (forward-char -1))
        (duplicate-region num (point-at-bol) (1+ (point-at-eol))))
    #+END_SRC

    Let's bind the top level function to a sensible key.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c 2") 'duplicate-current-line-or-region)
    #+END_SRC

** Hide block of code

   Enable hide definitions functions
   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook 'hs-minor-mode)
     (global-set-key (kbd "C-c h") 'hs-toggle-hiding)

   #+END_SRC

* Completions
** Minibuffer (ido mode)

   Ido - interactive do - help us with switching between buffers, opening
   files and directories with a minimum of keystrokes. As you type in a
   substring, the list of buffers or files currently matching the
   substring are displayed as you type.

   There is an amazing [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Ido]] about Ido contains more details about how
   to leverage its functionalities to improve your productivity.

   #+begin_src emacs-lisp
     (use-package ido
       :ensure nil
       :init (setq ido-use-virtual-buffers t
		   ido-use-faces t
		   ido-case-fold nil
		   ido-auto-merge-work-directories-length -1
		   ;; speed up ido by using less candidates
		   ido-max-prospects 10
		   ;; don't try and guess if the string under point is a file
		   ido-use-filename-at-point nil
		   ;; match across entire string
		   ido-enable-flex-matching t
		   ido-create-new-buffer 'always)
       :config
       (ido-mode t)
       (ido-everywhere t)
       :bind (:map ido-common-completion-map
		   ("M-e" . ido-edit-input)
		   ("M-r" . ido-toggle-regexp)))
   #+end_src

   More functionality

      1. After =C-x b=, the buffer at the head of the list can be killed
         by pressing =C-k=.
      2. After =C-x C-f=, you can delete (i.e. physically remove) the
         file at the head of the list with =C-k=


   Nice description of ido at the help page on [[help:ido][C-h P ido]].

   Always rescan buffer for imenu
   #+BEGIN_SRC emacs-lisp
     (set-default 'imenu-auto-rescan t)

     (add-to-list 'ido-ignore-directories "target")
   #+END_SRC

   A very interesting guide to Ido is from [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Mastering Emacs]]. I read it
   very often.

** Company mode

   Company is a text completion framework for Emacs. The name stands for
   "complete anything". It uses pluggable back-ends and front-ends to
   retrieve and display completion candidates.

   #+begin_src emacs-lisp
     (use-package company
       :ensure t
       :delight company-mode
       :init
       (setq company-show-numbers t
   	  company-dabbrev-downcase nil
   	  company-dabbrev-ignore-case t
   	  company-tooltip-limit 10
   	  company-minimum-prefix-length 2
   	  company-require-match 'never
   	  company-tooltip-align-annotations t
   	  company-transformers '(company-sort-by-occurrence)
   	  company-idle-delay 0.5)
       :config
       (global-company-mode t))
   #+end_src

   Also, we numbered all the candidates and the following code will
   enable us to choose the candidate based on its number. This solution
   was stolen from [[https://oremacs.com/2017/12/27/company-numbers/][link]] with some customization and simplification to
   provide only what I saw useful.

   #+begin_src emacs-lisp
     (defun ora-company-number ()
       "Choose the candidate based on his number at candidate list."
       (interactive)
       (let* ((k (this-command-keys))
   	   (re (concat "^" company-prefix k)))
         (if (cl-find-if (lambda (s) (string-match re s)) company-candidates)
   	  (self-insert-command)
   	(company-complete-number (string-to-number k)))))

     (defun ora-activate-number ()
       "Activate the number-based choices in company."
       (interactive)
       (let ((map company-active-map))
         (mapc
          (lambda (x)
   	 (define-key map (format "%d" x) 'ora-company-number))
          (number-sequence 0 9))
         ;; (define-key map " " (lambda ()
         ;; 			  (interactive)
         ;; 			  (company-abort)
         ;; 			  (self-insert-command 1)))
         (define-key map (kbd "<return>") nil)))

     (eval-after-load 'company
       '(ora-activate-number))
   #+end_src

** Hippie Expand

   [[https://www.emacswiki.org/emacs/HippieExpand][Hippie Expand]] is a more feature complete completion engine than the
   default dabbrev engine. The main feature I use over =dabbrev= is
   that is supports a wide range of backends for finding completions -
   =dabbrev= only looks at currently open buffers.

   #+BEGIN_SRC emacs-lisp
     (setq hippie-expand-try-functions-list
	   '(try-expand-dabbrev
	     try-expand-dabbrev-all-buffers
	     try-expand-dabbrev-from-kill
	     try-complete-file-name-partially
	     try-complete-file-name
	     try-expand-all-abbrevs
	     try-expand-list
	     try-expand-line
	     try-complete-lisp-symbol-partially
	     try-complete-lisp-symbol))
   #+END_SRC

   Then we override =dabbrev-expand='s keybinding to use
   =hippie-expand= instead.
   #+BEGIN_SRC emacs-lisp
     (define-key (current-global-map) [remap dabbrev-expand] 'hippie-expand)
   #+END_SRC

* Window

    Ease the task of changing window quickly.

    #+begin_src emacs-lisp
      (use-package ace-window
        :ensure t
        :init
        (setq aw-keys '(?h ?j ?k ?l ?y ?u ?i ?o ?p)
    	  aw-background nil
    	  aw-scope 'frame
    	  aw-dispatch-alist
    	  '((?s aw-swap-window "swap window")
    	    (?2 aw-split-window-vert "split window vertically")
    	    (?3 aw-split-window-horz "split window horizontally")
    	    (?? aw-show-dispatch-help)))
        :config
        (ace-window-display-mode -1)
        (global-set-key (kbd "C-x o") 'ace-window))
    #+end_src

    Don't popup certain buffers
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'display-buffer-alist
		   (cons "\\*Async Shell Command\\*.*"
			 (cons #'display-buffer-no-window nil)))
    #+END_SRC

** Winner

Winner is a built-in tool that keeps a record of buffer and window
layout changes. It then allows us to move back and forth in the
history of said changes. The mnemonic is related to Emacs default
commands to operating on windows (C-x 4) and the undo operations with
[uU] letter. 

There are some buffers that winner will not restore, I list them in
the *winner-boring-buffers*.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure nil
    :hook (after-init . winner-mode)
    :init
    (setq winner-dont-bind-my-keys t)
    (setq winner-boring-buffers
	  '("*Completions*"
	    "*Compile-Log*"
	    "*inferior-lisp*"
	    "*Fuzzy Completions*"
	    "*Apropos*"
	    "*Help*"
	    "*cvs*"
	    "*Buffer List*"
	    "*Ibuffer*"
	    "*esh command on file*"))
    :bind (("C-x 4 u" . winner-undo)
	   ("C-x 4 U" . winner-redo)))
#+END_SRC

* Dired

  Dired is very smart and usually finds the correct intent for some
  situations, and all of this is able through the DWIM variable. For
  example, if two buffers are open in the "dired" mode in different
  folders, if you git M to rename a file, it will move the file from
  folder A to B.

  #+BEGIN_SRC emacs-lisp
    (setq dired-dwim-target t)
  #+END_SRC

  Add the following to have file sizes given in "human-readable"
  format.
  #+BEGIN_SRC emacs-lisp
    (setq dired-listing-switches "-alh")
  #+END_SRC

** Guidelines

   Group of guidelines to help me remember dired functionalities

*** Mark files in Dired

    A very nice feature is to be able to edit Dired buffers as regular
    Emacs buffers. You can make several activities bearable using it,
    for more details follow this [[https://www.masteringemacs.org/article/wdired-editable-dired-buffers][guide]].

    You can mark in Dired buffer based on a search using =% m=. By using
    the letter =t= we can toggle the marked files. There is also the
    command =k= that hide all the mark file from the current view.

    You can always go back by pressing the better =g=

    #+caption: commands from dired discovered in the process of narrowing
    | chord | description                         |
    |-------+-------------------------------------|
    | % m   | mark files based on search          |
    | t     | toggle mark                         |
    | k     | hide marked files                   |
    | g     | rebuild the original tree           |
    | i     | list the content of a sub-directory |
    | C-x u | dired undo                          |

*** Replace text in multiple files

    Start dired and mark files as described in [[Mark files in Dired]],
    then use =Q= to run =query-replace= on all marked files.

** Ranger

   The package [[https://github.com/Fuco1/dired-hacks#dired-ranger][dired-ranger]] provides a useful extension to dired,
   allowing you to copy and paste files much like you can do in
   traditional GUI file explorers.

   #+BEGIN_SRC emacs-lisp
     (use-package dired-ranger
       :ensure t
       :bind (:map dired-mode-map
                   ("W" . dired-ranger-copy)
                   ("X" . dired-ranger-move)
                   ("Y" . dired-ranger-paste)))
   #+END_SRC

   Now in a dired buffer, you can mark multiple files and them hit =W=
   to copy them. You could then optionally go to another directory and
   mark more files and git =C-u W= to add those to the same entry in
   the copy ring as the previous files.

** Functions

   Some custom functions for Dired.

   #+begin_src emacs-lisp
       (require 'dired-x)

       (defun bk/dired-xdg-open ()
         "Open the file at point with xdg-open."
         (interactive)
         (let ((file (dired-get-filename nil t)))
           (message "Opening %s..." file)
           (call-process "xdg-open" nil 0 nil file)
           (message "Opening %s done" file)))

       (eval-after-load 'dired
         '(define-key dired-mode-map (kbd "O") 'bk/dired-xdg-open))
   #+end_src

   #+BEGIN_SRC emacs-lisp
       (defun bk/dired-directories-first ()
     "Sort dired listings with directories first."
     (save-excursion
       (let (buffer-read-only)
         (forward-line 2)
         (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
       (set-buffer-modified-p nil)))

       (advice-add 'dired-readin :after #'bk/dired-directories-first)
   #+END_SRC

   M-up is nicer in dired if it moves to the third line - straight to
   the "..", which M-down is nicer if it moves to the last file and
   finally C-a moving back to start of files.

   #+BEGIN_SRC emacs-lisp
     (defun dired-back-to-top ()
       (interactive)
       (beginning-of-buffer)
       (next-line 2)
       (dired-back-to-start-of-files))

     (defun dired-back-to-bottom ()
       (interactive)
       (end-of-buffer)
       (next-line -1)
       (dired-back-to-start-of-files))

     (defun dired-back-to-start-of-files ()
       (interactive)
       (backward-char (- (current-column) 2)))
   #+END_SRC

   Let's bind the functions defined above so it can take effect in
   dired.
   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'dired
       '(progn
          (define-key dired-mode-map (kbd "M-p") 'dired-back-to-top)
          (define-key dired-mode-map (kbd "M-n") 'dired-back-to-bottom)
          (define-key dired-mode-map (kbd "C-a") 'dired-back-to-start-of-files)))
   #+END_SRC

* TRAMP

  If TRAMP makes backup files, they should be better be kept locally
  than remote.
  #+BEGIN_SRC emacs-lisp
    (setq tramp-backup-directory-alist backup-directory-alist)
  #+END_SRC

* Version Control

  Sane config for =ediff= which is basically removing noisy
  highlights, avoiding crazy multi-frames setup, ignoring some
  whitespaces and windows should be side-by-side.

  #+BEGIN_SRC emacs-lisp
    (use-package ediff
      :init
      (setq ediff-highlight-all-diffs nil)
      (setq ediff-window-setup-function 'ediff-setup-windows-plain)
      (setq ediff-diff-options "-w")
      (setq ediff-split-window-function 'split-window-horizontally))
  #+END_SRC

** Magit

   A git porcelain inside Emacs. Magit is an interface to the version
   control system Git, implemented as an Emacs package. Magit aspires
   to be a complete Git porcelain, look for more info at [[https://github.com/magit/magit][here]].

    #+begin_src emacs-lisp
      (use-package magit
	:ensure t
	:init
	(setq magit-completing-read-function 'magit-ido-completing-read
	      ;; highlight individual word and letter changes when hunk diff displays
	      magit-diff-refine-hunk t
	      ;; don't tell me when magit reverts buffers
	      magit-revert-buffers 'silent
	      ;; always show the verbose diff in commit windows
	      magit-commit-arguments '("--verbose")
	      ;; timeout when magit takes a while to call out to git
	      magit-process-popup-time 10)
	:config
	(add-to-list 'magit-no-confirm 'stage-all-changes))
    #+end_src

*** Gitconfig

    [[https://github.com/magit/git-modes][gitconfig]] is a major mode for editing =gitconfig= files.
    #+BEGIN_SRC emacs-lisp
      (use-package gitconfig-mode
	:ensure t
	:config
	(require 'gitconfig-mode))
    #+END_SRC

*** Gitignore

    [[https://github.com/magit/git-modes][git-modes]] has a major mode for editing =gitignore= files.
    #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
	:ensure t
	:config
	(require 'gitignore-mode))
    #+END_SRC

** Time machine

    #+begin_src emacs-lisp
      (use-package git-timemachine :ensure t)
    #+end_src

** Visual identification

   Show differences between local and remote repo.

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :ensure t
       :init
       (setq diff-hl-side 'left)
       :config
       (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
       (diff-hl-flydiff-mode)
       (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
       (global-diff-hl-mode)
       
       (custom-set-faces
        '(diff-hl-change ((t (:background "#3a81c3"))))
        '(diff-hl-insert ((t (:background "#7ccd7c"))))
        '(diff-hl-delete ((t (:background "#ee6363"))))))
   #+END_SRC
** Miscellaneous

   #+BEGIN_SRC emacs-lisp
     (use-package browse-at-remote :ensure t)
     (use-package gitconfig-mode :ensure t)
     (use-package gitignore-templates :ensure t)

   #+END_SRC

* Search

** Wgrep

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep
       :ensure t)
   #+END_SRC

** Ripgrep

    #+BEGIN_SRC emacs-lisp
      (use-package rg
        :ensure t
        :config
        (rg-define-search bk/search-git-root-or-dir
          :query ask
          :format regexp
          :files "everything"
          :dir (let ((vc (vc-root-dir)))
    	     (if vc
    		 vc
    	       default-directory))
          :confirm prefix
          :flags ("--hidden -g !.git"))
        :bind
        ("M-s g" . bk/search-git-root-or-DIR))
    #+END_SRC

** Isearch

    You can invoke it using =C-s= and typing your desired search
    string. Also, if you want to use the regexp flavour you can use
    =M-C-s=.

    Run =C-h k C-s= yo get an /awesome/ help menu with all the extra
    keys you can use with =isearch=. These are the ones I use the
    most:

    | Keybindings                   | Description                                |
    |-------------------------------+--------------------------------------------|
    | C-s                           | search forward                             |
    | C-r                           | search backward                            |
    | M-C-s                         | search forward using regexp                |
    | M-C-r                         | search backward using regexp               |
    | C-s C-w                       | search word at point                       |
    | M-s                           | is a prefix while in isearch mode          |
    | (while isearch activated) M-r | turn your regular isearch into regexp mode |
    | M-s .                         | search for thing at point                  |
    | M-s o                         | get the results in occur buffer            |
    | M-s h r                       | highlight regexp                           |
    | M-s h u                       | undo the highlight                         |
    | C-s M-r                       | toggle regexp search                       |

** Occur

   Let's use an =occur= snippet from [[https://oremacs.com/2015/01/26/occur-dwim/][(or emacs]]. It will offer as the
   default candidate:
   - the current region, if it's active
   - the current symbol, otherwise

   #+BEGIN_SRC emacs-lisp
     (defun occur-dwim ()
       "Call `occur' with a sane default."
       (interactive)
       (push (if (region-active-p)
		 (buffer-substring-no-properties
		  (region-beginning)
		  (region-end))
	       (let ((sym (thing-at-point 'symbol)))
		 (when (stringp sym)
		   (regexp-quote sym))))
	     regexp-history)
       (call-interactively 'occur))

     (global-set-key (kbd "M-s o") 'occur-dwim)
   #+END_SRC

* Shell

    #+begin_src emacs-lisp
      (use-package eshell-bookmark
        :ensure t
        :config
        (add-hook 'eshell-mode-hook 'eshell-bookmark-setup))

      (setenv "PAGER" "cat")

      (defun eshell-clear-buffer ()
        "Clear the terminal buffer."
        (interactive)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (eshell-send-input)))

      (add-hook 'eshell-mode-hook (lambda ()
    				(local-set-key (kbd "C-l") 'eshell-clear-buffer)))

    #+end_src

    #+begin_src emacs-lisp
      (require 'em-alias)
      (add-hook 'eshell-mode-hook
    	    (lambda ()
    	      (eshell/alias "e" "find-file $1")
    	      (eshell/alias "ee" "find-file-other-window $1")))
    #+end_src

* General Programming 

Sometimes I place some TODO and FIXME words in the middle of my code
so I can come back to it latter and work on the subjects. The
following snippet will highlight these words to help me identify them.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (defun bk--add-watchwords ()
			      (font-lock-add-keywords
			       nil `(("\\<\\(FIX\\(ME\\))?\\|TODO\\)"
				      1 font-lock-warning-face t)))))
#+END_SRC

** Whitespaces

Control your whitespaces!

#+BEGIN_SRC emacs-lisp
  (require 'whitespace)
  (setq whitespace-style '(trailing lines space-before-tab
                    indentation space-after-tab))
  (setq whitespace-line-column 100)
  (whitespace-mode +1)
#+END_SRC

A less intrusive ‘delete-trailing-whitespaces’ on save.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :ensure t
    :delight ws-butler-mode
    :config
    (ws-butler-global-mode +1))
#+END_SRC
** Clojure

 Unfortunately, Emacs does not have a builtin major mode for Clojure,
 however we have a great community that support any programming
 language available in the world as a major mode of emacs rsrs.

 The intent of a major mode is basically provide font-lock,
 indentation, navigation and refactoring for the target programming
 language.

 At the =clojure-mode= website recommends us to use the MELBA Stable
 bundle because the MELPA version is following a development branch of
 the library. As this mode is very important for me right now, I would
 like to stick to the more stable branch.

 #+begin_src emacs-lisp
   (use-package clojure-mode
     :ensure t
     :delight (clojure-mode "λ")
     :init
     (setq clojure-align-forms-automatically t)
     :config
     (add-hook 'clojure-mode-hook 'smartparens-strict-mode)
     (add-hook 'clojure-mode-hook 'eldoc-mode)
     (add-hook 'clojure-mode-hook 'subword-mode))
 #+end_src

 The previous setting =clojure-align-forms-automatically= makes the
 following example a default behavior and you don't need to manually
 align the values. **NOTE**: this is an experiment, 90% of the time
 this happened to me, that was the default behavior I wanted. Let's see
 how much the other 10% will annoy me now.

 #+BEGIN_SRC clojure
   (def my-map
     {:a-key 1
      :other-key 2})

   ;; after C-c SPC
   (def my-map
     {:a-key     1
      :other-key 2})
 #+END_SRC


 There are several incredible examples of refactoring in the
 [[https://github.com/clojure-emacs/clojure-mode][clojure-mode]] website.

    1. TODO: Study refactoring support in clojure-mode.


 Provides additional refactoring support, but as we see from the
 =clojure-mode= github page, all these extra functionalities are
 migrating to the clojure mode package.

 #+begin_src emacs-lisp
   (use-package clj-refactor
     :ensure t
     :delight clj-refactor-mode
     :after (clojure-mode)
     :init
     (setq cljr-magic-require-namespaces '(("io" . "clojure.java.io")
					   ("set" . "clojure.set")
					   ("walk" . "clojure.walk")
					   ("zip" . "clojure.zip")
					   ("time" . "clj-time.core")
					   ("log" . "clojure.tools.logging")
					   ("json" . "cheshire.core")
					   ("client" . "org.httpkit.client")
					   ("http" . "clj-http.core")
					   ("a" . "clojure.core.async")
					   ("jdbc" . "next.jdbc")
					   ("s" . "clojure.spec.alpha")
					   ("gen" . "clojure.spec.gen.alpha")))
     :config
     (add-hook 'clojure-mode-hook (lambda ()
				    (clj-refactor-mode t)
				    (cljr-add-keybindings-with-prefix "C-c C-m"))))
 #+end_src


 We also improved the font-locking for built-in methods and macros of
 clojure.

 #+begin_src emacs-lisp
   (use-package clojure-mode-extra-font-locking
     :ensure t
     :after (clojure-mode))
 #+end_src

 Now comes the real deal for Clojure development, CIDER extends Emacs
 with support for interactive programming in Clojure. It basically
 connects the buffer to a nREPL and communicate back-and-forth to
 provide functionalities such as code completion, documentation,
 navigation, debugging, running tests, and many more.

    1. TODO:  Study cider mode


 #+begin_src emacs-lisp
   (use-package cider
     :ensure t
     :after (clojure-mode)
     :config
     (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
     (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
     (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion))
 #+end_src

 When cider is not connected, I usually use some commands that makes no
 sense in =clojure-mode= and receive a non-sense error message that I
 never understand what is happening or even worse it just hands without
 no feedback.

 I will borrow the idea from Alex Baranosky and create a dummy function
 to provide some useful feedback message to my future self.

 #+begin_src emacs-lisp
   (defun bk/nrepl-warn-when-not-connected ()
     (interactive)
     (message "Oops! You're not connected to an nREPL server. Please run M-x cider or M-x cider-jack-in to connect"))
 #+end_src

 And bind this to the most common keys that requires cider activated.

 #+begin_src emacs-lisp
   (define-key clojure-mode-map (kbd "C-x C-e") 'bk/nrepl-warn-when-not-connected)
   (define-key clojure-mode-map (kbd "C-c C-k") 'bk/nrepl-warn-when-not-connected)
   (define-key clojure-mode-map (kbd "C-c C-z") 'bk/nrepl-warn-when-not-connected)
 #+end_src


 Often I need to fire a repl and investigate some properties better, I
 have a =temp= project setup in my machine a simple =lein new temp=
 where I have some libraries already in the =project.clj= dependency
 available. The following function helps me get there quickly and
 require some frequent namespaces.

 #+begin_src emacs-lisp
   (defun bk/repl ()
     "Start an interactive repl in a temp project"
     (interactive)
     (cider-jack-in '(:project-dir "/home/wand/temp"))
     (add-hook 'cider-connected-hook
	       (lambda ()
		 (cider-repl-set-ns "user")
		 (cider-nrepl-sync-request:eval "(require '[clj-time.core :as t])")
		 (cider-nrepl-sync-request:eval "(require '[clj-http.core :as client])")
		 (cider-nrepl-sync-request:eval "(require '[org.httpkit.client :as http])")
		 (cider-nrepl-sync-request:eval "(require '[clojure.core.async :as a])")
		 (cider-nrepl-sync-request:eval "(require '[cheshire.core :as json])"))))
 #+end_src

   Let's make a nice usage of =babashka= scripting for clojure and
   print a random doc-string message in the initial of my Emacs
   session.
   #+begin_src emacs-lisp
     (let ((clj-docstring (shell-command-to-string "docstring.clj")))
       (when clj-docstring
	 (setq initial-scratch-message clj-docstring)))
   #+end_src

   The =docstring.clj= content is pretty small and it required [[https://github.com/borkdude/babashka][babashka]]
   to be installed, the content:

   #+BEGIN_SRC clojure
     #!/usr/bin/env bb

     (require '[clojure.repl])

     (defmacro random-doc []
       (let [sym (-> (ns-publics 'clojure.core) keys rand-nth)]
	 (if (:doc (meta (resolve sym)))
	   `(clojure.repl/doc ~sym)
	   `(random-doc))))

     (random-doc)
   #+END_SRC

   I added the new file to my PATH variable. That's all.

   #+begin_src emacs-lisp
     (defun bk/clj-random-docstring ()
       "Random doc-string into new buffer."
       (interactive)
       (let ((docstring (shell-command-to-string "docstring.clj"))
	     (buffer-name "*Clojure Random Docs*"))
	 (when (get-buffer buffer-name)
	   (kill-buffer buffer-name))
	 (get-buffer-create buffer-name)
	 (with-current-buffer buffer-name (insert docstring))
	 (switch-to-buffer-other-window buffer-name)
	 (special-mode)))
   #+end_src


 Clojure rocks!
** Python

   #+BEGIN_SRC emacs-lisp
     (use-package elpy
       :ensure t
       :config
       (elpy-enable)
       (pyvenv-activate "~/miniconda3")
       (delete `elpy-module-django elpy-modules)
       (delete `elpy-module-highlight-indentation elpy-modules))

     (use-package py-autopep8
       :ensure t
       :init
       (setq py-autopep8-options '("--max-line-length=250"))
       :config
       (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
   #+END_SRC
** SQL

 #+begin_src emacs-lisp
   (use-package sqlup-mode
     :ensure t
     :config
     (add-hook 'sql-mode-hook 'sqlup-mode)
     (add-hook 'sql-interactive-hook 'sqlup-mode)
     (add-to-list 'sqlup-blacklist "name"))
 #+end_src

 This Emacs library provides commands and a minor mode for easily
 reformating SQL using external programs such as pgformatter which can
 be installed in Arch Linux using =yaourt -S pgformatter-git=

 #+begin_src emacs-lisp
   (use-package sqlformat
     :ensure t
     :init
     (setq sqlformat-command 'pgformatter
	   sqlformat-args '("-s2" "-g"))
     :config
     (add-hook 'sql-mode-hook 'sqlformat-on-save-mode))
 #+end_src

 Indentation is also important

 #+begin_src emacs-lisp
   (use-package sql-indent
     :ensure t
     :delight sql-mode "Σ "
     :after (:any sql sql-interactive-mode)
     :config
     (add-hook 'sql-mode-hook 'sqlind-minor-mode))
 #+end_src

** Latex

 #+BEGIN_SRC emacs-lisp
   (use-package tex-site
     :ensure auctex
     :config
     (require 'latex)
     (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
           TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view))
           TeX-source-correlate-start-server t)

     ;; to refresh the buffer after compilation
     (add-hook 'TeX-after-compilation-finished-functions
               #'TeX-revert-document-buffer))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (use-package reftex
     :ensure t
     :config
     (setq reftex-cite-prompt-optional-args t))

   (setq TeX-auto-save t
         TeX-parse-self t
         TeX-save-query nil
         TeX-PDF-mode t)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (add-hook 'LaTeX-mode-hook 'visual-line-mode)
   (add-hook 'LaTeX-mode-hook 'flyspell-mode)
   (add-hook 'LaTeX-mode-hook 'Latex-math-mode)
   (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

   (with-eval-after-load 'tex
     (add-to-list 'safe-local-variable-values
                  '(TeX-command-extra-options . "-shell-escape")))
 #+END_SRC

** Linters

 =Flycheck= is a modern on-the-fly syntax checking extension for GNU
 Emacs, intended as replacement for the older Flymake.

 #+begin_src emacs-lisp
   (use-package flycheck
     :ensure t
     :init
     (setq flycheck-check-syntax-automatically '(mode-enabled save)
	   flycheck-display-errors-delay .3)
     :config
     (global-flycheck-mode))

   (use-package flycheck-clj-kondo :ensure t)
 #+end_src

 A very important command you should remember is =C-c ! v= or (=M-x
 flycheck-verify-setup=) that can help you verify for your current mode
 if everything is fine with your linter and it's backend.

 The following package implements a minor-mode for displaying errors
 from Flycheck right below their reporting location, using overlays.

 #+begin_src emacs-lisp
   (use-package flycheck-inline
     :ensure t
     :after flycheck
     :config
     (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
 #+end_src

 Integrate [[Unified Modeling Language]] with flycheck to automatically
 check the syntax of your plantuml files on the fly.

 #+begin_src emacs-lisp
   (use-package flycheck-plantuml
     :ensure t
     :after flycheck
     :config
     (flycheck-plantuml-setup))
 #+end_src

** Unified Modeling Language

 The UML is a general-purpose, developmental, modeling language in the
 field of software engineering that is intended to provide a standard
 way to visualize the design of a system.

    1. any activities (jobs)
    2. individual components of the system
    3. how the system will run
    4. how entities interact with others
    5. external user interfaces

 The UML diagrams represent two different views of a system model

    - *Static* (or structural) view: emphasizes the static structure of
      the system using objects, attributes, operations and
      relationships. It includes class diagrams and composite structure
      diagrams.
    - *Dynamic* (or behavioral) view: emphasizes the dynamic behavior
      of the system by showing collaborations among objects and changes
      to the internal states of objects. This view includes sequence
      diagrams, activity diagrams and state machine diagrams.

 Let's see a very interesting cheatsheet now:

   [[./images/uml-1.png]]

   [[./images/uml-2.png]]

   [[./images/uml-3.png]]


 The internal setup in order to use it will happen though =PlantUML=
 which has an specific syntax but is very easy to pick it up, follow
 examples at the official documentation at [[https://plantuml.com/][webpage]].

 #+begin_src emacs-lisp
   (use-package plantuml-mode
     :ensure t
     :mode ("\\.plantuml\\'" "\\.puml\\'")
     :init
     (setq org-plantuml-jar-path "/home/wand/plantuml.jar")
     :config
     (require 'ob-plantuml))
 #+end_src

** Parenthesis

 #+begin_src emacs-lisp
   (use-package smartparens
     :ensure t
     :delight smartparens-strict-mode
     :init
     (setq sp-highlight-pair-overlay nil)
     :config
     (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
     (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)

     (with-eval-after-load "smartparens"
       ;; remove some pairs
       (sp-pair "'" nil :actions :rem)
       (sp-pair "`" nil :actions :rem)

       ;; include new wrap of pairs
       (sp-pair "(" ")" :wrap "M-(")
       (sp-pair "[" "]" :wrap "M-[")

       (sp-use-smartparens-bindings)		;enable default smartparens bindings

       (sp-local-tag 'markdown-mode "c" "```clojure" "```")
       (sp-local-tag 'markdown-mode "e" "```elisp" "```")
       (sp-local-tag 'markdown-mode "b" "```bash" "```")
       (sp-local-tag 'markdown-mode "p" "```python" "```")

       (define-key smartparens-mode-map (kbd "M-p") 'sp-prefix-pair-object)))
 #+end_src

* Additional Major Modes

** Rest client

 #+begin_src emacs-lisp
   (use-package restclient
     :ensure t
     :config
     (add-to-list 'auto-mode-alist '("\\.restclient\\'" . restclient-mode)))

   (use-package company-restclient
     :ensure t
     :after company
     :config
     (add-to-list 'company-backends 'company-restclient))

 #+end_src

** Markdown

     #+BEGIN_SRC emacs-lisp
       (use-package markdown-mode
         :ensure t
         :config
         (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
         (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
         (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode)))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (eval-after-load 'markdown-mode
	 '(progn
	    ;; `pandoc' is better than obsolete `markdown'
	    (when (executable-find "pandoc")
	      (setq markdown-command "pandoc -f markdown"))))
     #+END_SRC

     Edit markdown code block like Org.
     #+BEGIN_SRC emacs-lisp
       (use-package edit-indirect
         :ensure t
         :defer t)
     #+END_SRC

** Json

 #+begin_src emacs-lisp
   (use-package json-mode
     :ensure t
     :config
     (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode)))
 #+end_src

** Yaml

   Unfortunately, I have to deal with YAML files on my daily basis.
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t
       :config
       (add-hook 'yaml-mode-hook 'whitespace-mode)
       (add-hook 'yaml-mode-hook 'subword-mode))
   #+END_SRC

** Makefile

   #+BEGIN_SRC emacs-lisp
     (use-package make-mode
       :ensure t
       :mode (("Makefile" . makefile-gmake-mode)))
   #+END_SRC

* Notes

  #+BEGIN_SRC emacs-lisp
    (use-package deft
      :ensure t
      :config
      (setq deft-default-extension "org"
	    deft-use-filename-as-title nil
	    deft-use-filter-string-for-filename t
	    deft-file-naming-rules '((noslash . "-")
				     (nospace . "-")
				     (case-fn . downcase))
	    deft-extensions '("txt" "org")
	    deft-directory "~/notes"
	    deft-auto-save-interval 0
	    deft-text-mode 'org-mode
	    deft-recursive t))
  #+END_SRC

* PDF

PDF Tools is, among other things, a replacement of DocView for PDF
files. The key difference is that pages are not pre-rendered by
e.g. ghostscript and stored in the file-system, but rather created
on-demand and stored in memory.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :defer 1
    :magic ("%PDF" . pdf-view-mode)
    :init (pdf-tools-install :no-query))

  (use-package pdf-view
    :ensure nil
    :after pdf-tools
    :bind (:map pdf-view-mode-map
		("C-s" . isearch-forward)
		("d" . pdf-annot-delete)
		("h" . pdf-annot-add-highlight-markup-annotation)
		("t" . pdf-annot-add-text-annotation))
    :custom
    (pdf-view-display-size 'fit-page)
    (pdf-view-resize-factor 1.1)
    (pdf-view-use-unicode-ligther nil))
#+end_src

* Org mode

** Defaults

   When using =RET= over a link, please go to it.

   #+begin_src emacs-lisp
     (setq org-return-follows-link t)
   #+end_src

   Please, disable =flycheck= from org-src buffers. We always have errors
   in there related to some emacs-lisp checkers. Here is how to disable
   it.

   #+begin_src emacs-lisp
     (defun disable-flycheck-in-org-src-block ()
       (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

     (add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-block)
   #+end_src

*** Manipulating Sections

    Let's enable [[http://notesyoujustmightwanttosave.blogspot.com/2011/12/org-speed-keys.html][Org Speed Keys]]. The main purpose of Speed Keys is to
    speed up the execution of the most common tasks you do in Org
    Mode - like outline navigation, visibility cycling, and structure
    editing. They also support basic clock commands and meta data
    editing, however, in order to use them, the cursor needs to be at
    the beginning of a headline.

    #+BEGIN_SRC emacs-lisp
      (setq org-use-speed-commands t)
    #+END_SRC

    List of most randy commands:

    | Key   | Description                                                      |
    |-------+------------------------------------------------------------------|
    | #     | toggle COMMENT-in for an org-header                              |
    | s     | toggles narrowing to a subtree i.e. hide the rest of the doc     |
    | I/O   | clock In/Out to the task defined by the current heading          |
    | u     | jumping upwards to the parent heading                            |
    | c     | for cycling structure below current heading, or C cycling global |
    | i     | insert a new same-level heading below current heading            |
    | w     | refile current heading                                           |
    | t     | cycle through the available TODO states                          |
    | ^     | sort children of the current subtree                             |
    | n/p   | for next/previous visible heading                                |
    | f/b   | for next/previous same-level heading                             |
    | D/U   | move a heading Down/Up                                           |
    | L/R   | recursively promote (move leftwards) or demote (more rightwards) |
    | 1,2,3 | to mark a heading with priority                                  |

*** Seamless Navigation Between Source Blocks

    Toggle editing org-mode source blocks.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-e") #'org-edit-special)
      (define-key org-src-mode-map (kbd "s-e") #'org-edit-src-exit)
    #+END_SRC
** Table of Contents

   #+begin_src emacs-lisp
     (use-package toc-org
       :ensure t
       :init
       (setq toc-org-max-depth 3)
       :config
       (add-hook 'org-mode-hook 'toc-org-mode))
   #+end_src

   I need to control the window that pops up when I open the Org Src
   buffer to edit code.
   #+BEGIN_SRC emacs-lisp
     (setq org-src-window-setup 'current-window)
   #+END_SRC

** Capture

   #+begin_src emacs-lisp
     (require 'org-capture)
     (setq org-directory "/home/wand/org")
     (setq org-confirm-babel-evaluate nil)
     (setq org-agenda-files (list "/home/wand/org/todo.org"))
     (setq org-todo-keywords '((sequence "TODO(t)" "|" "DOING(d)" "|" "DONE(D)" "|" "CANCELLED(C)")
   			    (sequence "STUDY(s)" "|" "STUDIED(S)")
   			    (sequence "ACT(a)" "|" "ACTED(A)")))
     (setq org-capture-templates
   	'(("c" "Capture some concise actionable item and exist" entry
   	   (file+headline "todo.org" "Task list without a defined date")
   	   "* TODO [#B] %^{Title}\n :PROPERTIES:\n :CAPTURED: %U\n :END:\n\n %i %l" :immediate-finish t)
   	  ("t" "Task of importance with a tag, deadline, and further editable space" entry
   	   (file+headline "todo.org" "Task list with a date")
   	   "* %^{Scope of task||TODO [#A]|STUDY [#A]|Act on} %^{Title} %^g\n DEADLINE: %^t\n :PROPERTIES:\n :CONTEXT: %a\n:CAPTURED: %U\n :END:\n\n %i %?")))

     (setq org-agenda-window-setup 'only-window)

     ;;; after calling the `org-todo', the org mode tries to store some
     ;;; sort of a "note" using `org-store-log-note' function. I want that
     ;;; every modification done in my todo file save the file right after.
     (advice-add 'org-deadline :after (lambda (&rest _rest)
   				     (org-save-all-org-buffers)))
     (advice-add 'org-schedule :after (lambda (&rest _rest)
   				     (org-save-all-org-buffers)))
     (advice-add 'org-todo :after (lambda (&rest _rest)
   				 (org-save-all-org-buffers)))
     (advice-add 'org-store-log-note :after (lambda (&rest _rest)
   					   (org-save-all-org-buffers)))

   #+end_src

** Structure Templates

   The "Easy Templates" as often is mentioned, is the standard way in
   Emacs to handle inline code blocks when writing in literate
   programming style.

   You can find all the different available templates by `C-h v
   org-structure-template-alist`.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-structure-template-alist
		  (list "elisp" (concat "#+BEGIN_SRC emacs-lisp\n"
					"?\n"
					"#+END_SRC")))
   #+END_SRC

** Reveal.js

*** TODO More details from how to build one presentation using the package
There an exhaustive documentation about Reveal.js in the github
[[https://gitlab.com/oer/org-re-reveal][repository]], please follow the link if more is necessary.

#+begin_src emacs-lisp
  (use-package org-re-reveal
    :ensure t
    :after org
    :custom
    (org-reveal-mathjax t)
    (org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"))
#+end_src

* Projects

#+begin_src emacs-lisp 
  (use-package projectile
    :ensure t
    :delight '(:eval (concat " " (projectile-project-name)))
    :init
    (setq projectile-completion-system 'ido)
    :config
    (projectile-mode t)
    :bind-keymap
    ("C-c p" . projectile-command-map))

#+end_src

* Spelling

** Correct your spelling errors on the fly

   #+begin_src emacs-lisp
     (defun bk/spell-buffer-pt-BR ()
       "Spell check in portuguese."
       (interactive)
       (ispell-change-dictionary "pt_BR")
       (flyspell-buffer))

     (defun bk/spell-buffer-en ()
       "Spell check in english."
       (interactive)
       (ispell-change-dictionary "en_US")
       (flyspell-buffer))

     (use-package flyspell
       :ensure nil
       :delight flyspell-mode
       :config
       (add-hook 'prog-mode-hook 'flyspell-prog-mode)
       (add-hook 'text-mode-hook 'flyspell-mode)
       (define-key flyspell-mode-map (kbd "C-.") nil))
   #+end_src

   There is a nice package to help correcting previous words that
   improve upon the =flyspell-auto-correct-previous-word= function

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell-correct
       :ensure t
       :commands (flyspell-correct-word-generic
		  flyspell-correct-previous-word-generic)
       :config
       (require 'flyspell-correct-ido)
       (setq flyspell-correct-interface #'flyspell-correct-ido)
       :bind (:map flyspell-mode-map
		   ("C-;" . flyspell-correct-wrapper)))
   #+END_SRC

   By default the *flyspell-correct-wrapper* is the most convenient
   way to use the package because it will jump to the first misspelled
   word before the point and prompts for correction and gets you
   back. Calling it with C-u gives ability to correct *multiple
   misspelled words* in one run. With C-u C-u changes direction and
   C-u C-u C-u changes direction and enables multiple corrections.
** Using a Grammar & Style Checker

   Let's install [[https://github.com/mhayashi1120/Emacs-langtool][a grammar and style checker]]. We get the offline tool
   from the [[https://languagetool.org/download/LanguageTool-4.9.zip][link]], then relocate it as follows.

   #+BEGIN_SRC emacs-lisp
     (use-package langtool
       :ensure t
       :config
       (setq langtool-language-tool-jar "/home/wand/.emacs.d/var/LanguageTool-4.5/languagetool-commandline.jar"))
   #+END_SRC

   Now we can run =langtool-check= on a grammatically incorrect text
   which colors errors in red, when we click on them we get the reason
   why; then we may invoke =langtool-correct-buffer= to quickly use
   the suggestions to fix each correction, and finally invoke
   =language-check-done= to stop any remaining red coloring.

   Let's verify if our installation is working by using a piece of
   incorrect text from Language Tool website:

   #+BEGIN_EXAMPLE
     LanguageTool offers spell and grammar checking. Just paste your text here
     and click the 'Check Text' button. Click the colored phrases for details
     on potential errors. or use this text too see an few of of the problems
     that LanguageTool can detecd. What do you thinks of grammar checkers?
     Please not that they are not perfect. Style issues get a blue marker:
     It's 5 P.M. in the afternoon. The weather was nice on Thursday, 27 June 2017
     --uh oh, that's the wrong date ;-)
   #+END_EXAMPLE

   #+BEGIN_SRC emacs-lisp
     ;; ;; Quickly check, correct, then clean up /region/ with M-^

     ;; (add-hook 'langtool-error-exists-hook
     ;;   (lambda ()
     ;;     (langtool-correct-buffer)
     ;;     (langtool-check-done)
     ;;   ))

     ;; (global-set-key "\M-^" 'langtool-check)
   #+END_SRC
** Synonyms

   Synosaurus is a thesaurus frontend for Emacs with pluggable
   backends. It has basically three commands:

   | Key       | Commands                      | Description          |
   |-----------+-------------------------------+----------------------|
   | C-c C-s l | synosaurus-lookup             | query you for a word |
   | C-c C-s r | synosaurus-choose-and-replace |                      |
   | C-c C-s i | synosaurus-choose-and-insert  |                      |

   #+BEGIN_SRC emacs-lisp

     (use-package synosaurus
       :ensure t
       :init (synosaurus-mode)
       :config
       (setq synosaurus-choose-method 'popup)
       :bind
       ("M-#" . synosaurus-choose-and-replace))
   #+END_SRC

   The thesaurus is powered by the Wordnet =wn= tool, which can be
   invoked without an internet connection.

   #+BEGIN_SRC shell
     yaourt -S wordnet-common
   #+END_SRC

   Let's use Wordnet as a dictionary via the [[https://github.com/gromnitsky/wordnut][wordnut]] package.
   #+BEGIN_SRC emacs-lisp
     (use-package wordnut
       :ensure t
       :bind
       ("M-!" . wordnut-lookup-current-word))
   #+END_SRC

   Some keys you can use inside the =*WordNut*= buffer.

   | Key          | Description                                           |
   |--------------+-------------------------------------------------------|
   | Enter        | Lookup a word under the cursor                        |
   | o            | A tooltip w/ a sense for the current lexical category |
   | /            | new search                                            |
   | l, r         | move backward/forward in history                      |
   | h            | view history                                          |
   | q            | hide buffer                                           |
   | M-up, M-down | move between sections                                 |
   | Space        | Page Down                                             |
   | b, Backspace | Page Up                                               |

** Translate

   To assist in language learning, it may be nice to have Emacs
   interface to Google translate e.g. invoke
   =google-translate-at-point=.

   #+BEGIN_SRC emacs-lisp
     (use-package google-translate
       :ensure t
       :config
       (require 'google-translate-smooth-ui)
       (global-set-key (kbd "C-c g t") 'google-translate-smooth-translate))

     ;; temporary fix for error args-out-of-range
     ;; https://github.com/atykhonov/google-translate/issues/98
     (defun google-translate-json-suggestion (json)
       "Retrieve from JSON (which returns by the
     `google-translate-request' function) suggestion. This function
     does matter when translating misspelled word. So instead of
     translation it is possible to get suggestion."
       (let ((info (aref json 7)))
	 (if (and info (> (length info) 0))
	     (aref info 1)
	   nil)))

   #+END_SRC

** Typing

   Practice touch typing using =speed-type=.
   #+BEGIN_SRC emacs-lisp
     (use-package speed-type
       :ensure t)
   #+END_SRC

   Running =M-x speed-type-region= on a region of text, or =M-x
   speed-type-buffer= on a whole buffer, or just =M-x speed-type-text=
   will produce the selected region, buffer, or random text for
   practice.

   A better alternative is to use [[https://www.emacswiki.org/emacs/TypingOfEmacs][Typing of Emacs]] which is far more
   interactive.
   #+BEGIN_SRC emacs-lisp
     (use-package typing
       :ensure t)
   #+END_SRC

   There are a few external websites that can help you with that too,
   [[https://typing.io/][Typing.io]] is the most recommended for Programmers. Check it out!
* Snippets

  Yasnippet is a template system for Emacs. It allows you to type an
  abbreviation and automatically expand it into function templates.

   #+begin_src emacs-lisp
     (use-package yasnippet
       :ensure t
       :delight yas-minor-mode
       :config
       (yas-global-mode +1)
       (define-key yas-minor-mode-map (kbd "<tab>") nil)
       (define-key yas-minor-mode-map (kbd "TAB") nil)
       (define-key yas-minor-mode-map (kbd "C-c y") #'yas-expand))
   #+end_src

   But since some specific version, yasnippet does not bundles
   snippets directly, you have to get them from third-party packages.

   #+begin_src emacs-lisp
       ;;; a snippet collection maintained by AndreaCrotti.
     (use-package yasnippet-snippets :ensure t)
   #+end_src


   I want to rely more on snippets on my day-to-day, therefore I need
   way to visualize if there is an existent snippet for a particular
   situation. You can do that with `M-x yas/describe-table'.


   I will place that in my cheatsheet too and a nice shortcut: C-c s.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c s")
		     (lambda ()
		       (interactive)
		       (yas/describe-tables)
		       (other-window 1)))

   #+END_SRC

   Jump to end of snippet definition

   #+BEGIN_SRC emacs-lisp
     (define-key yas-keymap (kbd "<return>") 'yas-exit-all-snippets)
   #+END_SRC

* Docker

#+begin_src emacs-lisp
  (use-package docker
    :ensure t
    :bind
    ("C-c d" . docker))

  (use-package docker-tramp
    :ensure t)

  (use-package dockerfile-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
    (add-to-list 'auto-mode-alist '("DockerfileDev\\'" . dockerfile-mode)))

  (use-package docker-compose-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("docker-compose[^/]*\\.yml\\'" . docker-compose-mode)))

  (defun bk/dockerfile-add-build-args ()
    "Add env variables to your docker build."
    (interactive)
    (let* ((vars (read-from-minibuffer "sequence of <envName>=<envValue>: "))
	   (split-vars (split-string vars " ")))
      (setq dockerfile-build-args nil)
      (dolist (v split-vars)
	(add-to-list 'dockerfile-build-args v))
      (setq docker-build-history-args vars)))


  (defun bk/docker-compose-custom-envs ()
    "Add usual env variables to Emacs environment."
    (interactive)
    (let* ((idu (shell-command-to-string "id -u"))
	   (idg (shell-command-to-string "id -g"))
	   (uid (string-join (vector (string-trim idu) ":" (string-trim idg)))))
      (setenv "WEBSERVER_PORT" "3000")
      (setenv "CURRENT_UID" uid)
      (message "setenv WEBSERVER_PORT=3000 CURRENT_UID=$(id -u):$(id -g) done!")))

  (defun bk/docker-cleanup-buffers ()
    "Delete all the docker buffers created."
    (interactive)
    (kill-matching-buffers "docker" nil t))

#+end_src

* Spotify

  #+BEGIN_SRC emacs-lisp
    (use-package helm-spotify-plus
      :ensure t
      :config
      (global-set-key (kbd "C-c m s") 'helm-spotify-plus)
      (global-set-key (kbd "C-c m f") 'helm-spotify-plus-next)
      (global-set-key (kbd "C-c m b") 'helm-spotify-plus-previous)
      (global-set-key (kbd "C-c m p") 'helm-spotify-plus-play)
      (global-set-key (kbd "C-c m g") 'helm-spotify-plus-pause))
  #+END_SRC

* RSS Feed

I like to read about programming, but Emacs and Clojure are by far the
most interesting communities I know so far, therefore, my feeds have
many links from these subjects.

#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :commands (elfeed elfeed-update)
    :config
    (setq-default elfeed-search-filter "@24-months-ago +unread")
    (setq elfeed-feeds
	  '(("http://lambda-the-ultimate.org/rss.xml" functional)
	    ("https://byorgey.wordpress.com/feed/" functional)
	    ("http://gigasquidsoftware.com/atom.xml" clojure)
	    ("http://swannodette.github.com/atom.xml" clojure)
	    ("https://rigsomelight.com/feed.xml" clojure)
	    ("https://lambdaisland.com/feeds/blog.atom" clojure)
	    ("https://nullprogram.com/feed/" programming)
	    ("http://feeds.feedburner.com/cognicast" clojure)
	    ("http://feeds2.feedburner.com/StuartSierra" clojure)
	    ("http://feeds.feedburner.com/Juxt" clojure)
	    ("http://blog.cognitect.com/blog?format=rss" clojure)
	    ("https://existentialtype.wordpress.com/feed/" functional)
	    ("http://insideclojure.org/feed.xml" clojure)
	    ("https://yogthos.net/feed.xml" clojure)
	    ("http://endlessparentheses.com/atom.xml" emacs)
	    ("http://www.blackhats.es/wordpress/?feed=rss2" emacs)
	    ("http://www.howardism.org/index.xml" emacs)
	    ("http://www.masteringemacs.org/feed/" emacs)
	    ("http://tonsky.me/blog/atom.xml" clojure)
	    ("http://www.clojure.net/rss.xml" clojure)
	    ("https://www.youtube.com/feeds/videos.xml?user=techguruuk" emacs)
	    ("http://emacsrocks.com/atom.xml" emacs)
	    ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
	    ("http://yqrashawn.com/feeds/lazyblorg-all.atom_1.0.links-only.xml" emacs))))

#+end_src

By default, s run a live filter and you can type something like "Xah"
to dynamically narrow the list of stories to those containing that
string. The only problem is that you need an extra whitespace before
the word, " Xah", let's fix that.

#+BEGIN_SRC emacs-lisp
  (defun bk/elfeed-search-live-filter-space ()
    "Insert space when running elfeed filter"
    (interactive)
    (let ((elfeed-search-filter (concat elfeed-search-filter " ")))
      (elfeed-search-live-filter)))

  (eval-after-load 'elfeed
    '(define-key elfeed-search-mode-map (kbd "/") 'bk/elfeed-search-live-filter-space))
#+END_SRC

* Slack

Slack from Emacs? :O Why not? I am having a terrible time configuring
all my workspaces lately. Therefore, it sounds like a perfect
opportunity to leverage the best tool for the job once again.

#+BEGIN_SRC emacs-lisp
  (use-package slack
    :ensure t
    :init
    (setq slack-buffer-emojify t
	  slack-prefer-current-team t
	  slack-buffer-function #'switch-to-buffer
	  slack-completing-read-function #'ido-completing-read
	  slack-display-team-name nil)
    :config
    (slack-register-team
     :name "captalysdev"
     :default t
     :token (auth-source-pick-first-password
	     :host "slack.com"
	     :user "captalysdev")
     :subscribed-channels '(onboarding geral dev)
     :full-and-display-names t)

    (slack-register-team
     :name "clojurians"
     :token (auth-source-pick-first-password
	     :host "slack.com"
	     :user "clojurians")
     :subscribed-channels '(beginners reitit))

    (slack-register-team
     :name "captalys-oficial"
     :token (auth-source-pick-first-password
	     :host "slack.com"
	     :user "captalys-oficial")
     :subscribed-channels '(devops)
     :full-and-display-names t))

#+END_SRC

Bring up the mentions menu with `@', and insert a space afterwards.
#+BEGIN_SRC emacs-lisp
  (define-key slack-mode-map "@"
    (defun endless/slack-message-embed-mention ()
      (interactive)
      (call-interactively #'slack-message-embed-mention)
      (insert " ")))
#+END_SRC


CRUD on messages
#+BEGIN_SRC emacs-lisp
  (define-key slack-mode-map (kbd "C-c C-d") #'slack-message-delete)
  (define-key slack-mode-map (kbd "C-c C-e") #'slack-message-edit)
  (define-key slack-mode-map (kbd "C-c C-k") #'slack-channel-leave)
#+END_SRC

Circe is a client for IRC in Emacs. It tries to have sane defaults,
and integrates well with the rest of the editor.

#+BEGIN_SRC emacs-lisp
  (use-package circe :ensure t)
#+END_SRC

Emojify is an Emacs extension to display emojis.
#+BEGIN_SRC emacs-lisp
  (use-package emojify
    :ensure t
    :commands (emojify-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package alert
    :commands (alert)
    :init
    (setq alert-default-style 'libnotify))
#+END_SRC


How to use Slack on emacs? Some terminology from the website:

| Function                   | Description                                                                        |
|----------------------------+------------------------------------------------------------------------------------|
| im                         | an IM (instant message) is a direct message between you and exactly one other user |
| channel                    | A channel is a slack channel which you are a member of                             |
| group                      | Any chat (direct message or channel) which isn't an IM is a group                  |
| slack-register-team        | set team configuration and create team                                             |
| slack-change-current-team  | change slack-current-team var                                                      |
| slack-start                | do authorize and initialze                                                         |
| slack-ws-close             | turn off websocket connection                                                      |
| slack-group-select         | select group from list                                                             |
| slack-im-select            | select direct message from list                                                    |
| slack-channel-select       | select channel from list                                                           |
| slack-group-list-update    | update group list                                                                  |
| slack-channel-list-update  | update channel list                                                                |
| slack-message-embed-mentio | use to mention to user                                                             |
| slack-file-upload          | uploads a file                                                                     |

* Telegram

  One more chat service that we need to stay in touch with friends and
  community.

  #+BEGIN_SRC emacs-lisp
    (use-package telega
      :ensure t
      :hook ((telega-root-mode . emojify-mode)
             (telega-chat-mode . emojify-mode))
      :init
      (setq telega-animation-play-inline nil)
      :config
      (telega-notifications-mode 1))
  #+END_SRC

* Pomodoro

#+begin_src emacs-lisp 
  (use-package tomatinho
    :ensure t
    :bind
    ("<f10>" . tomatinho))
#+end_src

* Advice

** Pop to mark
   When popping the mark, continue popping until the cursor actually
   moves. Also, if the last command was a copy - skip past all the
   expand-region craft.
   #+BEGIN_SRC emacs-lisp
     (defadvice pop-to-mark-command (around ensure-new-position activate)
       (let ((p (point)))
	 (when (eq last-command 'save-region-or-current-line)
	   ad-do-it
	   ad-do-it
	   ad-do-it)
	 (dotimes (i 10)
	   (when (= p (point)) ad-do-it))))

     (setq set-mark-command-repeat-pop t)
   #+END_SRC

** Yank indent

   This was stolen from [[https://github.com/milkypostman/dotemacs/blob/master/init.el][here.]] The idea is to indent yanked regions in
   specific modes that you can define.

   #+BEGIN_SRC emacs-lisp
     (defvar yank-indent-modes '(prog-mode
                                 js2-mode)
       " Modes in which to indent regions that are yanked (or yank-popped)")

     (defvar yank-advised-indent-threshold 1000
       " Threshhold (# chars) over which indentation does not automatically occur.")

     (defun yank-advise-indent-function (beg eng)
       "Do indentation, as long as the region isn't too large."
       (if (<= (- end beg) yank-advised-indent-threshold)
           (indent-region beg end nil)))

     (defadvice yank (after yank-indent activate)
       "If current mode is one of `yank-indent-modes', indent yanked text."
       (if (and (not (ad-get-arg 0))
                (member major-mode yank-indent-modes))
           (let ((transient-mark-mode nil))
             (yank-advise-indent-function (region-beginning) (region-end)))))

     (defadvice yank-pop (after yank-pop-indent activate)
       "If the current mode is one of `yank-indent-modes', indent yanked text."
       (if (and (not (ad-get-arg 0))
                (member major-mode yank-indent-modes))
           (let ((transient-mark-mode nil))
             (yank-advise-indent-function (region-beginning) (region-end)))))

     (defun yank-unindented ()
       (interactive)
       (yank 1))
   #+END_SRC

* General custom functions
** HTTP-based
*** Find my current IP

   #+begin_src emacs-lisp
     (defvar url-http-end-of-headers)
     (defun bk/ip ()
       "Find my current public IP address."
       (interactive)
       (let* ((endpoint "https://api.ipify.org")
   	   (myip (with-current-buffer (url-retrieve-synchronously endpoint)
   		   (buffer-substring (+ 1 url-http-end-of-headers) (point-max)))))
         (kill-new myip)
         (message "IP: %s" myip)))
   #+end_src

** Editing
*** what? sudo!

   #+BEGIN_SRC emacs-lisp
     (defun bk/sudo-edit (&optional arg)
       "Function to edit file with super-user with optional ARG."
       (interactive "P")
       (if (or arg (not buffer-file-name))
           (find-file (concat "/sudo:root@localhost:" (read-file-name "File: ")))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+END_SRC
*** eval and replace

    #+BEGIN_SRC emacs-lisp
      (defun eval-and-replace ()
        "Replace the preceding sexp with its value."
        (interactive)
        (backward-kill-sexp)
        (condition-case nil
            (prin1 (eval (read (current-kill 0)))
                   (current-buffer))
          (error (message "invalid expression")
                 (insert (current-kill 0)))))
    #+END_SRC

** Buffer
*** Kill buffer and the file associated

   #+BEGIN_SRC emacs-lisp
     (defun bk/kill-buffer-and-file (buffer-name)
       "Removes file connected to current buffer and kills buffer."
       (interactive "bKill buffer and its file:")
       (let* ((buffer (get-buffer buffer-name))
   	   (filename (buffer-file-name buffer)))
         (if (not (and filename (file-exists-p filename)))
   	  (error "Buffer '%s' is not visiting a file!" buffer-name)
   	(delete-file filename)
   	(kill-buffer buffer))))
   #+END_SRC

* Keys

** Hint
   #+begin_src emacs-lisp
     (use-package which-key
       :ensure t
       :delight which-key-mode
       :init
       (setq which-key-use-C-h-commands t
   	  which-key-separator " - "
   	  which-key-show-prefix 'echo
   	  which-key-popup-type 'side-window)
       :config
       (which-key-mode))
   #+end_src

** Global definitions

   #+begin_src emacs-lisp
     (global-set-key "\C-x3" (lambda ()
   			    (interactive)
   			    (split-window-horizontally)
   			    (other-window 1)))

     (global-set-key "\C-x2" (lambda ()
   			    (interactive)
   			    (split-window-vertically)
   			    (other-window 1)))

     (global-set-key (kbd "C-x C-m") 'smex)
     (global-set-key (kbd "M-x") 'smex)
     (global-set-key (kbd "M-i") 'change-inner)
     (global-set-key (kbd "M-o") 'change-outer)
     (global-set-key (kbd "C-c e") 'eshell)
     (global-set-key (kbd "C-c g s") 'magit-status)
     (global-set-key (kbd "C-c C-k") 'eval-buffer)
     (global-set-key (kbd "C-x C-b") 'ibuffer)
     (global-set-key (kbd "C-c t") 'org-capture)
     (global-set-key (kbd "C-c a") 'org-agenda)
     (global-set-key (kbd "C-=") 'er/expand-region)
     (global-set-key (kbd "C-x p") 'pop-to-mark-command)

     ;; by default C-x k prompts to select which buffer should be selected.
     (global-set-key (kbd "C-x k") (lambda ()
   				  (interactive)
   				  (kill-buffer (current-buffer))))
   #+end_src


** Cast

   Show current command and its key in the mode line
   #+BEGIN_SRC emacs-lisp
     (use-package keycast
       :homepage https://github.com/tarsius/keycast
       :ensure t
       :defer t)
   #+END_SRC

* Emacs as my own Operating System

  Emacs as my full operating system is just too great. I have a small
  problem recently with this setup, I use an  60% Anne Pro 2 keyboard and
  its well known to be very but very buggy. The experience of the
  keyboard itself is incredible, but the firmware behind it is just
  unbearable, for some reason after hitting some keys my Emacs was
  halting. oO yes, complete halt for no reason whatsoever, seems like
  XKB and this firmware is not getting along nicely.

  I found an alternative to fix this issue by using EXWM alongside
  with LXDE. There are two files:

  =~/.config/lxsession/LXDE/autostart=
  #+BEGIN_SRC conf
    @pcmanfm --desktop --profile LXDE
    @xscreensaver -no-splash
  #+END_SRC

  =~/.config/lxsession/LXDE/desktop.conf=
  #+BEGIN_SRC conf
    [Session]
    window_manager=emacs
    disable_autostart=no
    polkit/command=lxpolkit
    clipboard/command=lxclipboard
    xsettings_manager/command=build-in
    proxy_manager/command=build-in
    keyring/command=ssh-agent
    quit_manager/command=lxsession-logout
    lock_manager/command=lxlock
    terminal_manager/command=lxterminal
    quit_manager/image=/usr/share/lxde/images/logout-banner.png
    quit_manager/layout=top

    [GTK]
    iXft/Antialias=1
    iXft/Hinting=1
    sXft/HintStyle=hintslight
    sXft/RGBA=rgb
    sNet/ThemeName=Clearlooks
    sNet/IconThemeName=nuoveXT2
    iNet/EnableEventSounds=1
    iNet/EnableInputFeedbackSounds=1
    sGtk/ColorScheme=
    sGtk/FontName=Sans 10
    iGtk/ToolbarStyle=3
    iGtk/ToolbarIconSize=3
    iGtk/ButtonImages=1
    iGtk/MenuImages=1
    iGtk/CursorThemeSize=18
    sGtk/CursorThemeName=DMZ-White

    [Mouse]
    AccFactor=20
    AccThreshold=10
    LeftHanded=0

    [Keyboard]
    Delay=500
    Interval=30
    Beep=1

    [State]
    guess_default=true

    [Dbus]
    lxde=true

    [Environment]
    menu_prefix=lxde-
  #+END_SRC

  And don't forget to change the content of =~/.xinitrc= to =exec
  startlxde=.

  Ok, now let's start with EXWM configuration.

  #+BEGIN_SRC emacs-lisp
    (defun bk/keepmenu ()
      "Call password manager."
      (interactive)
      (start-process-shell-command "pwd" nil "keepmenu"))

    (defun bk/lock-screen ()
      (interactive)
      (start-process-shell-command "lock" nil "xscreensaver-command -lock"))

    (defun bk/qutebrowse ()
      (interactive)
      (start-process-shell-command "browser" nil "qutebrowser"))
  #+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :init
    (setq exwm-workspace-number 4
      use-dialog-box nil
      exwm-workspace-show-all-buffers nil
      exwm-layout-show-all-buffers t)
    :config
    (display-battery-mode t)
    (fringe-mode 1)

    (require 'exwm)
    (exwm-input-set-simulation-keys
     '(([?\C-p] . [up])
       ([?\C-n] . [down])
       ([?\C-f] . [right])
       ([?\C-b] . [left])
       ([?\C-s] . [\C-f])
       ([?\M-w] . [\C-c])
       ([?\C-y] . [\C-v])
       ([?\C-w] . [\C-x])))

    (setq exwm-input-global-keys
      `(([?\s-r] . exwm-reset)
        ([?\s-d] . dmenu)
        ([?\s-p] . bk/keepmenu)
        ([?\s-w] . exwm-workspace-switch)
        ([?\C-c \l] . bk/lock-screen)
        ,@(mapcar (lambda (i)
              `(,(kbd (format "s-%d" i)) .
                (lambda ()
                  (interactive)
                  (exwm-workspace-switch-create ,i))))
            (number-sequence 0 9))))
    (exwm-enable)

    (require 'exwm-config)
    (exwm-config-ido)

    ;; universal Get-me-outta-here
    (push ?\C-g exwm-input-prefix-keys)
    (exwm-input-set-key (kbd "C-g") #'keyboard-quit))
#+END_SRC

   Now that I am using Emacs as my window manager I can use the meta keys
   to provide operations over the windows itself, in other days, there
   were reserved to i3wm operations.

   #+BEGIN_SRC emacs-lisp
     (exwm-input-set-key (kbd "s-x") #'exwm-input-toggle-keyboard)
     (exwm-input-set-key (kbd "s-h") #'windmove-left)
     (exwm-input-set-key (kbd "s-j") #'windmove-down)
     (exwm-input-set-key (kbd "s-k") #'windmove-up)
     (exwm-input-set-key (kbd "s-l") #'windmove-right)
   #+END_SRC

   Ag has a very nice package to help us out in EXWM, the feature is
   similar in usage to Org-SRC-Blocks, therefore you press =C-c '= on
   input text boxes of other external apps and another window pops up so
   you can have all the Emacs under the finger while editing.

   #+BEGIN_SRC emacs-lisp
     (use-package exwm-edit
       :ensure t
       :after (exwm)
       :config
       (exwm-input-set-key (kbd "C-s-e") #'exwm-edit--compose))
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (use-package dmenu
       :ensure t
       :commands (dmenu))
   #+END_SRC

   I made a change in =qutebrowser= so every tab open is a new window of
   qutebrowser, therefore I can search for the tabs using =C-x b= from
   Emacs.

   =:set -t tabs.tabs_are_window true=

   More settings for qutebrowser can be found [[https://www.qutebrowser.org/doc/help/settings.html][here]].

   Disabling floating window
   #+BEGIN_SRC emacs-lisp
     (setq exwm-manage-force-tiling t)
   #+END_SRC

** Multiple Screens

   Stolen from [[https://www.reddit.com/r/emacs/comments/cyuqbp/exwm_multimonitor_setup/][reddit]] answer, however the original function is heavily
   customized to the authors setup, therefore I modified the
   appropriate bits.

   After some time working with the code I decided to try to make a
   package out of it. However, there are several moving peaces yet,
   however, is already useful for me.

   Work in Progress nevertheless...

   #+BEGIN_SRC emacs-lisp
     (require 'exwm-monitors)

     (exwm-monitors-define-screen-info
      :name "eDP1"
      :width 1600
      :height 900)

     (exwm-monitors-define-spec
      :name "home"
      :pred (list :only '("eDP1" "HDMI1"))
      :action (list '("eDP1" :off)
                    '("HDMI1" :right)))

     (defun bk/turn-x1-carbon-on ()
       (interactive)
       (exwm-monitors-define-spec
        :name "home"
        :pred (list :only '("eDP1" "HDMI1"))
        :action (list '("eDP1" :auto)
                      '("HDMI1" :right)))
       (exwm-monitors-initial-setup))

     (exwm-monitors-initial-setup)
   #+END_SRC

** System package

   Oh, this is nice! I can control =pacman= from Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package system-packages
       :ensure t
       :config
       (setq system-packages-use-sudo t))
   #+END_SRC

** Notification Daemon

   I need a notification daemon to alert me about all the statefull
   things changing around me. For now, I will use [[https://dunst-project.org/][Dunst]].

   #+BEGIN_SRC emacs-lisp
     (call-process-shell-command "nohup dunst >/dev/null &" nil 0)
   #+END_SRC

   There is a function to send an alert to the daemon.
   #+BEGIN_SRC emacs-lisp
     (defun dunst-alert (header string &rest objects)
       "Send an alert to the Dunst daemon."
       (let ((string (funcall #'format string objects))
             (command (format "notify-send -a \"%s\" \"%s\"" header string)))
         (call-process-shell-command command nil 0)))
   #+END_SRC

** Window behaviour

   In stock Emacs, EXWM uses =char mode= and =line mode= to
   distinguish between using the keyboard to control an application vs
   using the keyboard to control the application's *buffer*.


   Rename buffers to match the X11 window class or title:
   #+BEGIN_SRC emacs-lisp
     (defun exwm-rename-buffer ()
       (interactive)
       (exwm-workspace-rename-buffer
	(concat exwm-class-name ":"
		(if (<= (length exwm-title) 50) exwm-title
		  (concat (substring exwm-title 0 49))))))

     (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
     (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)

   #+END_SRC

   Window dividers make Emacs look far less sloppy, and provide
   divisions between windows that are significantly more visible.
   The color is grabbed from the mode line for consistency.
   #+BEGIN_SRC emacs-lisp
     (setq window-divider-default-right-width 3)
     (let ((color (face-background 'mode-line)))
       (dolist (face '(window-divider-first-pixel
		       window-divider-last-pixel
		       window-divider))
	 (set-face-foreground face color)))
     (window-divider-mode 1)
   #+END_SRC
** Key Bindings

   "Global key bindings" in EXWM work essentially anywhere, including
   buffers that are currently in char mode. The bindings below should
   be fairly straightforward.
   #+BEGIN_SRC emacs-lisp
   #+END_SRC

   Regular keys to control audio using the package pulseaudio.
   #+BEGIN_SRC emacs-lisp
     (use-package pulseaudio-control
       :ensure t
       :after (exwm)
       :config
       (exwm-input-set-key
	(kbd "<XF86AudioLowerVolume>")
	#'pulseaudio-control-decrease-volume)

       (exwm-input-set-key
	(kbd "<XF86AudioRaiseVolume>")
	#'pulseaudio-control-increase-volume)

       (exwm-input-set-key
	(kbd "<XF86AudioMute>")
	#'pulseaudio-control-toggle-current-sink-mute))
   #+END_SRC

   Control the backlight level
   #+BEGIN_SRC emacs-lisp
     (use-package emacs
       :ensure nil
       :after (exwm)
       :config
       (exwm-input-set-key
	(kbd "<XF86MonBrightnessDown>")
	(lambda () (interactive)
	  (start-process-shell-command "bdown" nil "xbacklight -dec 10")))

       (exwm-input-set-key
	(kbd "<XF86MonBrightnessUp>")
	(lambda () (interactive)
	  (start-process-shell-command "bdown" nil "xbacklight -inc 10"))))
   #+END_SRC

   More binding definitions
   #+BEGIN_SRC emacs-lisp
     (defun bk/qutebrowser ()
       "Open the browser"
       (interactive)
       (start-process-shell-command "brw" nil "qutebrowser"))

     (defun bk/fix-caps-and-key-rate ()
       "Capslock is another ctrl and key rate need to be higher"
       (interactive)
       (start-process-shell-command "caps" nil "setxkbmap -layout us -variant alt-intl -option ctrl:nocaps")
       (start-process-shell-command "krate" nil "xset r rate 300 50")
       (message "Ctrl and key rate fixed!"))

     (use-package emacs
       :ensure nil
       :after (exwm)
       :config
       (exwm-input-set-key (kbd "s-q") #'bk/qutebrowser)
       (exwm-input-set-key (kbd "C-c k") #'bk/fix-caps-and-key-rate))
   #+END_SRC

   Print screens are way to serious business.
   #+BEGIN_SRC emacs-lisp
     (defun bk/print-from-region ()
       "Print screen interactively."
       (interactive)
       (start-process-shell-command "pt" nil "scrot -s -e 'mv $f /home/wand/Pictures/'"))

     (exwm-input-set-key (kbd "<print>") #'bk/print-from-region)
   #+END_SRC

   System tray
   #+BEGIN_SRC emacs-lisp
     (defun exwm-bk/nm-applet ()
       (interactive)
       (start-process-shell-command "applt" nil
                    "nm-applet"))

     (defun exwm-bk/bluetooth ()
       (interactive)
       (start-process-shell-command "bl-applt" nil
                    "blueman-applet"))

     (defun exwm-bk/xscreensaver ()
       (interactive)
       (start-process-shell-command "xs" nil
                    "xscreensaver -no-splash"))

     (defun exwm-bk/key-rate ()
       (interactive)
       (start-process-shell-command "key-rate" nil
                    "xset r rate 300 50"))

     (defun exwm-bk/nocaps ()
       (interactive)
       (start-process-shell-command "nocaps" nil
                                    "setxkbmap -layout us -variant alt-intl -option ctrl:nocaps"))

     (use-package exwm-systemtray
       :ensure nil
       :init
       (setq exwm-systemtray-height 20)
       :config
       (exwm-systemtray-enable)
       (add-hook 'exwm-init-hook 'exwm-bk/nm-applet t)
       (add-hook 'exwm-init-hook 'exwm-bk/bluetooth t)
       (add-hook 'exwm-init-hook 'exwm-bk/xscreensaver)
       (add-hook 'exwm-init-hook 'exwm-bk/key-rate)
       (add-hook 'exwm-init-hook 'exwm-bk/nocaps))
   #+END_SRC

** Important commands

   | Keys | Command                    | Description                                 |
   |------+----------------------------+---------------------------------------------|
   | -    | exwm-workspace-move-window | send current window to a specific workspace |

* References

   1. [[https://github.com/ch11ng/exwm/wiki][EXWM User Guide]]
   2. [[https://github.com/bvk/config/blob/master/emacs/wm.el][EXWM config with support for external monitor]]
   3. [[https://www.reddit.com/r/emacs/comments/6huok9/exwm_configs/][Reddit EXWM Configs?]]
   4. [[https://github.com/agzam/dot-spacemacs/tree/master/layers/ag-exwm][Ag layer for EXWM]]
   5. [[https://github.com/kinleyd/configs/blob/master/init.el][Another great emacs.d focusing on EXWM]]
   6. [[https://www.reddit.com/r/emacs/comments/74hetz/emacs_everywhere/][Emacs Everywhere]] - by u/ambrevar. Very nice post on reddit.
   7. https://ambrevar.xyz/emacs/
   8. [[https://github.com/wasamasa/dotemacs/blob/master/init.org][Literate emacs ]] - by wasamasa
   9. [[https://github.com/farlado/dotemacs][Far from sane literate Emacs]] - by farlado
   10. [[http://pragmaticemacs.com/all-posts/][Pragmatic Emacs]] - Amazing blog with lots of Emacs customizations
