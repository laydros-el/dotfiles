#+title: Emacs literate configuration
#+author: Wanderson Ferreira
#+date: 2020:04:02

The =Old configuration= node below has all my previous =init.el= and I
am slowly refactoring into this literate configuration style. No
breaking changes is expected.

* Table of Contents                                                     :TOC:
- [[#packages][Packages]]
- [[#old-configuration][Old configuration]]
- [[#defaults][Defaults]]
  - [[#minibuffer][Minibuffer]]
  - [[#help][Help]]
- [[#aesthetics][Aesthetics]]
- [[#completions][Completions]]
  - [[#minibuffer-ido-mode][Minibuffer (ido mode)]]
  - [[#company-mode][Company mode]]
- [[#docker][Docker]]
- [[#rss-feed][RSS Feed]]
- [[#rest-client][Rest client]]
- [[#version-control][Version Control]]
  - [[#time-machine][Time machine]]
  - [[#aesthetics-1][Aesthetics]]
- [[#unified-modeling-language][Unified Modeling Language]]
- [[#search][Search]]
- [[#shell][Shell]]
- [[#clojure][Clojure]]
- [[#org-mode][Org mode]]

* Packages

Emacs facility to download and install "packages" that implement
additional features. You can find information about a specific package
by using =C-h P= that prompts for the name and shows more details.

There is a very detail package in Emacs help system that you can find
on [[info:emacs#Packages][info:emacs#Packages]]. 

I always start a new configuration setup with a naive mindset that I
will not install thousands of external packages, however they are so
good and make our life so much easier that is hard to avoid them
altogether.

Let's initialize the package system.
#+begin_src emacs-lisp :tangle yes
  (require 'package)

  (unless (bound-and-true-p package--initialized)
    (package-initialize))
#+end_src

Despite the fact that GNU Elpa, the standard repository, of Emacs
packages maintained by the core team already have many different
packages, I like to use another external repository called [[https://melpa.org/#/][Melpa]] which
is currently maintained by the community and curated by Purcell's and
his team.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
#+end_src

We need to refresh the archives to make this change to take place.

#+begin_src emacs-lisp :tangle yes
  (unless (file-exists-p "~/.emacs.d/elpa/archives/melpa")
    (package-refresh-contents))
#+end_src

Also, by default Emacs also automatically loads all installed packages
in subsequent Emacs session. I want to disable it.

#+begin_src emacs-lisp :tangle yes
  (setq package-enable-at-startup nil)
#+end_src

When you have more than a dozen packages, it makes the process of
managing them very difficult without any additional help. And by my
experience the only real issue is due to performance because you will
inevitably have many external packages loaded in situations where you
don't need it. Fortunately, Jon Wiegley made our lives easier by
creating =use-package=, please look for =C-h P use-package= to more
details.

#+begin_src emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package)
    (package-install 'diminish))

  (eval-when-compile
    '(require 'use-package))
#+end_src

* Old configuration
#+begin_src emacs-lisp :tangle yes
  (defvar my-external-packages '(smartparens
				 elfeed
				 rg
				 company
				 company-quickhelp
				 company-restclient
				 which-key
				 yasnippet
				 yasnippet-snippets
				 avy
				 ace-window
				 magit
				 git-timemachine
				 change-inner
				 smart-shift
				 flycheck
				 flycheck-clj-kondo
				 smex
				 docker
				 docker-tramp
				 dockerfile-mode
				 docker-compose-mode
				 eshell-bookmark
				 projectile
				 tomatinho
				 expand-region
				 restclient
				 json-mode
				 multiple-cursors
				 markdown-mode
				 fix-word
				 modus-operandi-theme
				 modus-vivendi-theme))

  (dolist (pkg my-external-packages)
    (unless (package-installed-p pkg)
      (package-install pkg)))

  ;; add new paths to emacs
  (setenv "PATH" (concat (getenv "PATH") ":/home/wand/scripts"))
  (setq exec-path (append exec-path '("/home/wand/scripts")))

  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
  (setq exec-path (append exec-path '("/usr/local/bin")))

  (smex-initialize)

  ;; aesthetics
  (setq inhibit-splash-screen t
	inhibit-startup-echo-area-message t)

  (defun bk/font-family-size (family size)
    "Set frame font to FAMILY at SIZE."
    (set-frame-font
     (concat family "-" (number-to-string size) ":hintstyle=hintfull") t t))

  (bk/font-family-size "Source Code Pro Medium" 12)

  (defun bk/load-light-theme ()
    "Load a light theme for the day."
    (interactive)
    (load-theme 'modus-operandi t))

  (defun bk/load-dark-theme ()
    "Load a dark theme for the night."
    (interactive)
    (load-theme 'modus-vivendi t))

  ;; before 17h just load my light theme pls
  (if (< (string-to-number (format-time-string "%H" (current-time))) 17)
      (bk/load-light-theme)
    (bk/load-dark-theme))

  (require 'ibuffer)
  (setq ibuffer-expert t)
  (setq ibuffer-saved-filter-groups
	'(("Main"
	   ("Directories" (mode . dired-mode))
	   ("Rest" (mode . restclient-mode))
	   ("Docker" (or
		      (mode . docker-compose-mode)
		      (mode . dockerfile-mode)))
	   ("Programming" (or
			   (mode . clojure-mode)
			   (mode . emacs-lisp-mode)
			   (mode . python-mode)))
	   ("Org" (mode . org-mode))
	   ("Markdown" (or
			(mode . markdown-mode)
			(mode . gfm-mode)))
	   ("Git" (or
		   (mode . magit-blame-mode)
		   (mode . magit-cherry-mode)
		   (mode . magit-diff-mode)
		   (mode . magit-log-mode)
		   (mode . magit-process-mode)
		   (mode . magit-status-mode)))
	   ("Emacs" (or
		     (name . "^\\*Help\\*$")
		     (name . "^\\*Custom.*")
		     (name . "^\\*Org Agenda\\*$")
		     (name . "^\\*info\\*$")
		     (name . "^\\*scratch\\*$")
		     (name . "^\\*Backtrace\\*$")
		     (name . "^\\*Messages\\*$"))))))

  (add-hook 'ibuffer-mode-hook (lambda () (ibuffer-switch-to-saved-filter-groups "Main")))

  (require 'ibuffer-vc)
  (define-key ibuffer-mode-map (kbd "/ V") 'ibuffer-vc-set-filter-groups-by-vc-root)

  ;; help to change text
  ;; move text using C-c up/down
  (global-smart-shift-mode t)

  ;; docker
  (require 'dockerfile-mode)
  (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
  (add-to-list 'auto-mode-alist '("DockerfileDev\\'" . dockerfile-mode))

  (defun bk/dockerfile-add-build-args ()
    "Add env variables to your docker build."
    (interactive)
    (let* ((vars (read-from-minibuffer "sequence of <envName>=<envValue>: "))
	   (split-vars (split-string vars " ")))
      (setq dockerfile-build-args nil)
      (dolist (v split-vars)
	(add-to-list 'dockerfile-build-args v))
      (setq docker-build-history-args vars)))

  (add-to-list 'auto-mode-alist '("docker-compose[^/]*\\.yml\\'" . docker-compose-mode))

  (defun bk/docker-compose-custom-envs ()
    "Add usual env variables to Emacs environment."
    (interactive)
    (let* ((idu (shell-command-to-string "id -u"))
	   (idg (shell-command-to-string "id -g"))
	   (uid (string-join (vector (string-trim idu) ":" (string-trim idg)))))
      (setenv "WEBSERVER_PORT" "3000")
      (setenv "CURRENT_UID" uid)
      (message "setenv WEBSERVER_PORT=3000 CURRENT_UID=$(id -u):$(id -g) done!")))

  (global-set-key (kbd "C-c d") 'docker)

  (add-hook 'eshell-mode-hook 'eshell-bookmark-setup)

  (defun eshell-clear-buffer ()
    "Clear the terminal buffer."
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))

  (add-hook 'eshell-mode-hook (lambda ()
				(local-set-key (kbd "C-l") 'eshell-clear-buffer)))

  (defun bk/docker-cleanup-buffers ()
    "Delete all the docker buffers created."
    (interactive)
    (kill-matching-buffers "docker" nil t))

  ;; git
  (require 'magit)
  (add-to-list 'magit-no-confirm 'stage-all-changes)

  (require 'dired-x)

  ;; useful option when I want to rename/move files in dired
  (setq dired-dwim-target t)

  (defun bk/dired-directories-first ()
    "Sort dired listings with directories first."
    (save-excursion
      (let (buffer-read-only)
	(forward-line 2)
	(sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))

  (advice-add 'dired-readin :after #'bk/dired-directories-first)

  (defun bk/dired-xdg-open ()
    "Open the file at point with xdg-open."
    (interactive)
    (let ((file (dired-get-filename nil t)))
      (message "Opening %s..." file)
      (call-process "xdg-open" nil 0 nil file)
      (message "Opening %s done" file)))

  (define-key dired-mode-map (kbd "O") 'bk/dired-xdg-open)

  (global-set-key "\C-x3" (lambda ()
			    (interactive)
			    (split-window-horizontally)
			    (other-window 1)))

  (global-set-key "\C-x2" (lambda ()
			    (interactive)
			    (split-window-vertically)
			    (other-window 1)))

  (global-set-key (kbd "C-x C-m") 'smex)
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-i") 'change-inner)
  (global-set-key (kbd "M-o") 'change-outer)
  (global-set-key (kbd "C-c e") 'eshell)
  (global-set-key (kbd "C-c g s") 'magit-status)
  (global-set-key (kbd "C-c C-k") 'eval-buffer)
  (global-set-key (kbd "C-x C-j") 'dired-jump)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "<f10>") 'tomatinho)
  (global-set-key (kbd "C-c t") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-=") 'er/expand-region)
  (global-set-key (kbd "C-x p") 'pop-to-mark-command)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

  (set-register ?e '(file . "~/.emacs.d/init.el"))
  (set-register ?t '(file . "~/org/todo.org"))
  (set-register ?c '(file . "~/.emacs.d/docs/cheatsheet.org"))

  ;; `C-a' first takes you to the first non-whitespace char as
  ;; `back-to-indentation' on a line, and if pressed again takes you to
  ;; the actual beginning of the line.
  (defun smarter-move-beginning-of-line (arg)
    "Move depending on ARG to beginning of visible line or not.
  From https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/."
    (interactive "^p")
    (setq arg (or arg 1))
    (when (/= arg 1)
      (let ((line-move-visual nil))
	(forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
	(move-beginning-of-line 1))))

  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)

  ;; disable modes
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  ;; enable modes
  (show-paren-mode t)
  (delete-selection-mode t)
  (pending-delete-mode t)
  (global-eldoc-mode t)
  (global-prettify-symbols-mode t)
  (display-time-mode t)
  (blink-cursor-mode 0)

  (setq which-key-add-column-padding 12)
  (setq which-key-allow-imprecise-window-fit t)
  (setq which-key-echo-keystrokes 0.2)
  (setq which-key-idle-delay 0.8)

  (which-key-mode)

  (line-number-mode)
  (column-number-mode)
  (size-indication-mode)
  (global-auto-revert-mode)


  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
	aw-background nil)
  (global-set-key (kbd "C-x o") 'ace-window)

  ;; winner
  (setq winner-dont-bind-my-keys t)
  (add-hook 'after-init-hook 'winner-mode)
  (global-set-key (kbd "C-x 4 u") 'winner-undo)
  (global-set-key (kbd "C-x 4 U") 'winner-redo)

  ;; input one char, jump to it with a tree
  (global-set-key (kbd "C-c ;") 'avy-goto-char)

  ;; completions
  (recentf-mode t)

  (require 'company)
  (setq company-require-match 'never
	company-show-numbers t
	company-transformers '(company-sort-by-occurrence)
	company-idle-delay 0.3)

  (add-to-list 'company-backends 'company-restclient)

  (add-hook 'after-init-hook 'global-company-mode)

  ;; very interesting behavior which is to choose the candidate based on its number
  ;; this feature was implemented by ora in his blog post
  (defun ora-company-number ()
    "Choose the candidate based on his number at candidate list."
    (interactive)
    (let* ((k (this-command-keys))
	   (re (concat "^" company-prefix k)))
      (if (cl-find-if (lambda (s) (string-match re s)) company-candidates)
	  (self-insert-command)
	(company-complete-number (string-to-number k)))))

  (defun ora-activate-number ()
    "Activate the number-based choices in company."
    (interactive)
    (let ((map company-active-map))
      (mapc
       (lambda (x)
	 (define-key map (format "%d" x) 'ora-company-number))
       (number-sequence 0 9))
      (define-key map " " (lambda ()
			    (interactive)
			    (company-abort)
			    (self-insert-command 1)))
      (define-key map (kbd "<return>") nil)))

  (ora-activate-number)

  ;; provide documentation to the candidates of company mode
  (eval-after-load 'company
    '(company-quickhelp-mode))

  (add-hook 'text-mode-hook #'auto-fill-mode)

  (setq sp-highlight-pair-overlay nil)

  (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
  (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)

  (with-eval-after-load "smartparens"
    ;; remove some pairs
    (sp-pair "'" nil :actions :rem)
    (sp-pair "`" nil :actions :rem)

    ;; include new wrap of pairs
    (sp-pair "(" ")" :wrap "M-(")
    (sp-pair "[" "]" :wrap "M-[")

    (sp-use-smartparens-bindings)		;enable default smartparens bindings

    (sp-local-tag 'markdown-mode "c" "```clojure" "```")
    (sp-local-tag 'markdown-mode "e" "```elisp" "```")
    (sp-local-tag 'markdown-mode "b" "```bash" "```")
    (sp-local-tag 'markdown-mode "p" "```python" "```")

    (define-key smartparens-mode-map (kbd "M-p") 'sp-prefix-pair-object))

  (with-eval-after-load 'projectile
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-mode-line-prefix " Proj"))
  (projectile-mode)

  (setq tab-always-indent 'complete)
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  (setq custom-safe-themes t)

  (require 'em-alias)
  (add-hook 'eshell-mode-hook
	    (lambda ()
	      (eshell/alias "e" "find-file $1")
	      (eshell/alias "ee" "find-file-other-window $1")))

  (defvar mode-line-cleaner-alist
    `((eldoc-mode . "")
      (abbrev-mode . "")
      (company-mode . "")
      (yas-minor-mode . "")
      (auto-fill-mode . "")
      (auto-revert-mode . "")
      (subword-mode . "")
      (flyspell-mode . "")
      (which-key-mode . "")
      (emacs-lisp-mode . "λ")))

  (defun clean-mode-line ()
    "Clean your modeline."
    (interactive)
    (cl-loop for cleaner in mode-line-cleaner-alist
	     do (let* ((mode (car cleaner))
		       (mode-str (cdr cleaner))
		       (old-mode-str (cdr (assq mode minor-mode-alist))))
		  (when old-mode-str
		    (setcar old-mode-str mode-str))
		  (when (eq mode major-mode)
		    (setq mode-name mode-str)))))

  (add-hook 'after-change-major-mode-hook #'clean-mode-line)

  (require 'org-capture)
  (setq org-directory "/home/wand/org")
  (setq org-confirm-babel-evaluate nil)
  (setq org-agenda-files (list "/home/wand/org/todo.org"))
  (setq org-todo-keywords '((sequence "TODO(t)" "|" "DOING(d)" "|" "DONE(D)" "|" "CANCELLED(C)")
			    (sequence "STUDY(s)" "|" "STUDIED(S)")
			    (sequence "ACT(a)" "|" "ACTED(A)")))
  (setq org-capture-templates
	'(("c" "Capture some concise actionable item and exist" entry
	   (file+headline "todo.org" "Task list without a defined date")
	   "* TODO [#B] %^{Title}\n :PROPERTIES:\n :CAPTURED: %U\n :END:\n\n %i %l" :immediate-finish t)
	  ("t" "Task of importance with a tag, deadline, and further editable space" entry
	   (file+headline "todo.org" "Task list with a date")
	   "* %^{Scope of task||TODO [#A]|STUDY [#A]|Act on} %^{Title} %^g\n DEADLINE: %^t\n :PROPERTIES:\n :CONTEXT: %a\n:CAPTURED: %U\n :END:\n\n %i %?")))

  (setq org-agenda-window-setup 'only-window)

  ;;; imenu - produces menus for accessing locations in documents
  ;; for source-code buffer the locations to index are typically definitions
  ;; of functions, variables, and so on.
  (require 'imenu)

  (defun ido-menu--read (index-alist &optional prompt)
    "Show imenu INDEX-ALIST on ido interface as PROMPT."
    (let* ((symatpt (thing-at-point 'symbol))
	   (names (mapcar 'car index-alist))
	   (name (ido-completing-read (or prompt "imenu ") names
				      nil t nil nil nil))
	   (choice (assoc name index-alist)))
      (if (imenu--subalist-p choice)
	  (ido-menu--read (cdr choice) prompt nil)
	choice)))

  (defun bk/ido-menu ()
    "Public interface to my custom imenu through ido."
    (interactive)
    (let ((index-alist (cdr (imenu--make-index-alist))))
      (if (equal index-alist '(nil))
	  (message "No imenu tags in buffer")
	(imenu (ido-menu--read index-alist nil)))))

  (global-set-key (kbd "C-.") 'bk/ido-menu)

  (defvar url-http-end-of-headers)
  (defun bk/ip ()
    "Find my current public IP address."
    (interactive)
    (let* ((endpoint "https://api.ipify.org")
	   (myip (with-current-buffer (url-retrieve-synchronously endpoint)
		   (buffer-substring (+ 1 url-http-end-of-headers) (point-max)))))
      (kill-new myip)
      (message "IP: %s" myip)))


  (defalias 'yes-or-no-p 'y-or-n-p)

  (add-to-list 'auto-mode-alist '("\\.restclient\\'" . restclient-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode))

  (autoload 'markdown-mode "markdown-mode"
    "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

  (autoload 'gfm-mode "markdown-mode"
    "Major mode for editing Github flavored markdown files" t)
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))


  ;;; after calling the `org-todo', the org mode tries to store some
  ;;; sort of a "note" using `org-store-log-note' function. I want that
  ;;; every modification done in my todo file save the file right after.
  (advice-add 'org-deadline :after (lambda (&rest _rest)
				     (org-save-all-org-buffers)))
  (advice-add 'org-schedule :after (lambda (&rest _rest)
				     (org-save-all-org-buffers)))
  (advice-add 'org-todo :after (lambda (&rest _rest)
				 (org-save-all-org-buffers)))
  (advice-add 'org-store-log-note :after (lambda (&rest _rest)
					   (org-save-all-org-buffers)))

  (setq flycheck-check-syntax-automatically '(mode-enabled save))
  (global-flycheck-mode)

  (require 'flycheck-clj-kondo)

  ;; spelling
  (defun bk/spell-buffer-pt-BR ()
    "Spell check in portuguese."
    (interactive)
    (ispell-change-dictionary "pt_BR")
    (flyspell-buffer))

  (defun bk/spell-buffer-en ()
    "Spell check in english."
    (interactive)
    (ispell-change-dictionary "en_US")
    (flyspell-buffer))

  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
  (add-hook 'text-mode-hook 'flyspell-mode)

  ;; integrate emacs kill ring with the system clipboard.
  (setq save-interprogram-paste-before-kill t)


  ;; built in htop
  (setq proced-auto-update-flag t
	proced-auto-update-interval 1
	proced-descend t)

  ;; words
  (global-set-key (kbd "M-u") #'fix-word-upcase)
  (global-set-key (kbd "M-l") #'fix-word-downcase)
  (global-set-key (kbd "M-c") #'fix-word-capitalize)

  ;; feed
  (require 'elfeed)
  (setq-default elfeed-search-filter "@24-months-ago +unread")
  (setq elfeed-feeds
	'(("http://lambda-the-ultimate.org/rss.xml" functional)
	  ("https://byorgey.wordpress.com/feed/" functional)
	  ("http://gigasquidsoftware.com/atom.xml" clojure)
	  ("http://swannodette.github.com/atom.xml" clojure)
	  ("https://rigsomelight.com/feed.xml" clojure)
	  ("https://lambdaisland.com/feeds/blog.atom" clojure)
	  ("https://nullprogram.com/feed/" programming)
	  ("http://feeds.feedburner.com/cognicast" clojure)
	  ("http://feeds2.feedburner.com/StuartSierra" clojure)
	  ("http://feeds.feedburner.com/Juxt" clojure)
	  ("http://blog.cognitect.com/blog?format=rss" clojure)
	  ("https://existentialtype.wordpress.com/feed/" functional)
	  ("http://insideclojure.org/feed.xml" clojure)
	  ("https://yogthos.net/feed.xml" clojure)
	  ("http://endlessparentheses.com/atom.xml" emacs)
	  ("http://www.blackhats.es/wordpress/?feed=rss2" emacs)
	  ("http://www.howardism.org/index.xml" emacs)
	  ("http://www.masteringemacs.org/feed/" emacs)
	  ("http://tonsky.me/blog/atom.xml" clojure)
	  ("http://www.clojure.net/rss.xml" clojure)
	  ("https://www.youtube.com/feeds/videos.xml?user=techguruuk" emacs)
	  ("http://emacsrocks.com/atom.xml" emacs)
	  ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
	  ("http://yqrashawn.com/feeds/lazyblorg-all.atom_1.0.links-only.xml" emacs)))

  (setq-default abbrev-mode t)

  (defun bk/add-region-local-abbrev (start end)
    "Go from START to END and add the selected text to a local abbrev."
    (interactive "r")
    (if (use-region-p)
	(let ((num-words (count-words-region start end)))
	  (add-mode-abbrev num-words)
	  (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a l") 'bk/add-region-local-abbrev)

  (defun bk/add-region-global-abbrev (start end)
    "Go from START to END and add the selected text to global abbrev."
    (interactive "r")
    (if (use-region-p)
	(let ((num-words (count-words-region start end)))
	  (add-abbrev global-abbrev-table "Global" num-words)
	  (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a g") 'bk/add-region-global-abbrev)

  ;; grep

  (require 'rg)
  (rg-define-search bk/search-git-root-or-dir
    :query ask
    :format regexp
    :files "everything"
    :dir (let ((vc (vc-root-dir)))
	   (if vc
	       vc
	     default-directory))
    :confirm prefix
    :flags ("--hidden -g !.git"))

  (global-set-key (kbd "M-s g") 'bk/search-git-root-or-dir)

  ;; snippets
  (yas-global-mode +1)
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "C-c y") #'yas-expand)
#+end_src

* Defaults

  Files...
  #+begin_src emacs-lisp :tangle yes
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))

    (when (file-exists-p custom-file)
      (load custom-file))
  #+end_src

  Let's make a nice usage of =babashka= scripting for clojure and
  print a random doc-string message in the initial of my Emacs
  session.
  #+begin_src emacs-lisp :tangle yes
    (let ((clj-docstring (shell-command-to-string "docstring.clj")))
      (when clj-docstring
	(setq initial-scratch-message clj-docstring)))
  #+end_src

  The =docstring.clj= content is pretty small and it required [[https://github.com/borkdude/babashka][babashka]]
  to be installed, the content:

  #+BEGIN_SRC clojure
    #!/usr/bin/env bb

    (require '[clojure.repl])

    (defmacro random-doc []
      (let [sym (-> (ns-publics 'clojure.core) keys rand-nth)]
	(if (:doc (meta (resolve sym)))
	  `(clojure.repl/doc ~sym)
	  `(random-doc))))

    (random-doc)
  #+END_SRC

  I added the new file to my PATH variable. That's all.

  #+begin_src emacs-lisp :tangle yes
    (defun bk/clj-random-docstring ()
      "Random doc-string into new buffer."
      (interactive)
      (let ((docstring (shell-command-to-string "docstring.clj"))
	    (buffer-name "*Clojure Random Docs*"))
	(when (get-buffer buffer-name)
	  (kill-buffer buffer-name))
	(get-buffer-create buffer-name)
	(with-current-buffer buffer-name (insert docstring))
	(switch-to-buffer-other-window buffer-name)
	(special-mode)))
  #+end_src

** Minibuffer

  The following setting prevent the minibuffer to grow, therefore it
  will be always 1 line height.

#+begin_src emacs-lisp :tangle yes
  (setq resize-mini-windows nil)
  (setq max-mini-window-height 1)
#+end_src

** Help

* Aesthetics
* Completions
** Minibuffer (ido mode)

The whole selling point to =ido-mode= is: switches between buffers and
opens files and directories with a minimum of keystrokes.

#+begin_src emacs-lisp :tangle yes
  (use-package ido
    :ensure nil
    :init (setq ido-use-virtual-buffers t
		ido-use-faces t
		ido-enable-flex-matching t
		ido-create-new-buffer 'always)
    :config
    (ido-mode t)
    (ido-everywhere t))
#+end_src


More functionality

   1. After =C-x b=, the buffer at the head of the list can be killed
      by pressing =C-k=.
   2. After =C-x C-f=, you can delete (i.e. physically remove) the
      file at the head of the list with =C-k=


We can find a nice description of ido at the help page on [[help:ido][C-h P ido]].

** Company mode
* Docker
* RSS Feed
* Rest client
* Version Control
** Time machine
** Aesthetics
* Unified Modeling Language

The UML is a general-purpose, developmental, modeling language in the
field of software engineering that is intended to provide a standard
way to visualize the design of a system.

   1. any activities (jobs)
   2. individual components of the system
   3. how the system will run
   4. how entities interact with others
   5. external user interfaces

The UML diagrams represent two different views of a system model

   - *Static* (or structural) view: emphasizes the static structure of
     the system using objects, attributes, operations and
     relationships. It includes class diagrams and composite structure
     diagrams.
   - *Dynamic* (or behavioral) view: emphasizes the dynamic behavior
     of the system by showing collaborations among objects and changes
     to the internal states of objects. This view includes sequence
     diagrams, activity diagrams and state machine diagrams.

Let's see a very interesting cheatsheet now:

  [[./images/uml-1.png]]

  [[./images/uml-2.png]]

  [[./images/uml-3.png]]


The internal setup in order to use it will happen though =PlantUML=
which has an specific syntax but is very easy to pick it up, follow
examples at the official documentation at [[https://plantuml.com/][webpage]].

#+begin_src emacs-lisp :tangle yes
  (use-package plantuml-mode
    :ensure t
    :init
    (setq org-plantuml-jar-path "/home/wand/plantuml.jar")
    :config
    (require 'ob-plantuml))
#+end_src

* Search
* Shell
* Clojure

Unfortunately, Emacs does not have a builtin major mode for Clojure,
however we have a great community that support any programming
language available in the world as a major mode of emacs rsrs.

The intent of a major mode is basically provide font-lock,
indentation, navigation and refactoring for the target programming
language.

At the =clojure-mode= website recommends us to use the MELBA Stable
bundle because the MELPA version is following a development branch of
the library. As this mode is very important for me right now, I would
like to stick to the more stable branch.

#+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode
    :ensure t
    :pin melpa-stable
    :diminish (clojure-mode "λ")
    :init
    (setq clojure-align-forms-automatically t)
    :config
    (add-hook 'clojure-mode-hook #'smartparens-strict-mode)
    (add-hook 'clojure-mode-hook #'eldoc-mode)
    (add-hook 'clojure-mode-hook #'subword-mode))
#+end_src

The previous setting =clojure-align-forms-automatically= makes the
following example a default behavior and you don't need to manually
align the values. **NOTE**: this is an experiment, 90% of the time
this happened to me, that was the default behavior I wanted. Let's see
how much the other 10% will annoy me now.

#+BEGIN_SRC clojure :tangle yes
  (def my-map
    {:a-key 1
     :other-key 2})

  ;; after C-c SPC
  (def my-map
    {:a-key     1
     :other-key 2})
#+END_SRC


There are several incredible examples of refactoring in the
[[https://github.com/clojure-emacs/clojure-mode][clojure-mode]] website. 

   1. TODO: Study refactoring support in clojure-mode.


Provides additional refactoring support, but as we see from the
=clojure-mode= github page, all these extra functionalities are
migrating to the clojure mode package.

#+begin_src emacs-lisp :tangle yes
  (use-package clj-refactor
    :ensure t
    :after (clojure-mode)
    :config
    (add-hook 'clojure-mode-hook (lambda ()
				   (clj-refactor-mode t)
				   (cljr-add-keybindings-with-prefix "C-c C-m"))))
#+end_src


We also improved the font-locking for built-in methods and macros of
clojure.

#+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode-extra-font-locking
    :ensure t
    :after (clojure-mode))
#+end_src

Now comes the real deal for Clojure development, CIDER extends Emacs
with support for interactive programming in Clojure. It basically
connects the buffer to a nREPL and communicate back-and-forth to
provide functionalities such as code completion, documentation,
navigation, debugging, running tests, and many more.

   1. TODO:  Study cider mode


#+begin_src emacs-lisp :tangle yes
  (use-package cider
    :ensure t
    :after (clojure-mode)
    :config
    (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion))
#+end_src

When cider is not connected, I usually use some commands that makes no
sense in =clojure-mode= and receive a non-sense error message that I
never understand what is happening or even worse it just hands without
no feedback.

I will borrow the idea from Alex Baranosky and create a dummy function
to provide some useful feedback message to my future self.

#+begin_src emacs-lisp :tangle yes
  (defun bk/nrepl-warn-when-not-connected ()
    (interactive)
    (message "Oops! You're not connected to an nREPL server. Please run M-x cider or M-x cider-jack-in to connect"))
#+end_src

And bind this to the most common keys that requires cider activated.

#+begin_src emacs-lisp :tangle yes
  (define-key clojure-mode-map (kbd "C-x C-e") 'bk/nrepl-warn-when-not-connected)
  (define-key clojure-mode-map (kbd "C-c C-k") 'bk/nrepl-warn-when-not-connected)
  (define-key clojure-mode-map (kbd "C-c C-z") 'bk/nrepl-warn-when-not-connected)
#+end_src

Clojure rocks!
* Org mode

Please, disable =flycheck= from org-src buffers. We always have errors
in there related to some emacs-lisp checkers. Here is how to disable
it.

#+begin_src emacs-lisp :tangle yes
  (defun disable-flycheck-in-org-src-block ()
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

  (add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-block)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package toc-org
    :ensure t
    :config
    (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src

