#+title: Emacs literate configuration
#+author: Wanderson Ferreira
#+date: 2020:04:02

Literate Emacs configuration style. This is part of my journey for
/Teach myself programming in 10 years/. I'm using this configuration
on a system running [[https://wiki.archlinux.org/][Arch Linux]] and Emacs 26.3, that's why this
configuration will be using the latest features and /not check/ for the
system it's running on.

*IMPORTANT* The default configuration will setup Emacs Window
Manager (EXWM), use with caution, I will make some defensive
configuration if you with to toggle this in the feature, for now, the
only user target of this file is myself.


* Table of Contents                                                     :TOC:
- [[#packages][Packages]]
- [[#operating-system][Operating System]]
- [[#aesthetics][Aesthetics]]
- [[#defaults][Defaults]]
  - [[#recentf][Recentf]]
  - [[#extended-command][Extended Command]]
  - [[#case-switch][Case switch]]
  - [[#registers][Registers]]
  - [[#abbreviation][Abbreviation]]
  - [[#imenu][Imenu]]
  - [[#ibuffer][Ibuffer]]
  - [[#minibuffer][Minibuffer]]
  - [[#help][Help]]
  - [[#webjump][Webjump]]
  - [[#authentication-source][Authentication Source]]
- [[#editing-text][Editing Text]]
  - [[#multiple-cursors][Multiple Cursors]]
  - [[#custom-functions][Custom functions]]
- [[#completions][Completions]]
  - [[#minibuffer-ido-mode][Minibuffer (ido mode)]]
  - [[#company-mode][Company mode]]
- [[#window][Window]]
  - [[#winner][Winner]]
- [[#dired][Dired]]
- [[#tramp][TRAMP]]
- [[#linters][Linters]]
- [[#docker][Docker]]
- [[#rss-feed][RSS Feed]]
- [[#slack][Slack]]
- [[#spotify][Spotify]]
- [[#rest-client][Rest client]]
- [[#version-control][Version Control]]
  - [[#magit][Magit]]
  - [[#time-machine][Time machine]]
  - [[#aesthetics-1][Aesthetics]]
  - [[#miscellaneous][Miscellaneous]]
- [[#unified-modeling-language][Unified Modeling Language]]
- [[#search][Search]]
  - [[#wgrep][Wgrep]]
  - [[#ripgrep][Ripgrep]]
  - [[#isearch][Isearch]]
- [[#shell][Shell]]
- [[#json][Json]]
- [[#general-programming][General Programming]]
  - [[#whitespaces][Whitespaces]]
- [[#markdown][Markdown]]
- [[#notes][Notes]]
- [[#pdf][PDF]]
- [[#latex][Latex]]
- [[#clojure][Clojure]]
- [[#python][Python]]
- [[#sql][SQL]]
- [[#parenthesis][Parenthesis]]
- [[#org-mode][Org mode]]
  - [[#revealjs][Reveal.js]]
- [[#projects][Projects]]
- [[#spelling][Spelling]]
- [[#snippets][Snippets]]
- [[#pomodoro][Pomodoro]]
- [[#general-custom-functions][General custom functions]]
- [[#keys][Keys]]
- [[#emacs-as-my-own-operating-system][Emacs as my own Operating System]]
  - [[#buffers][Buffers]]
  - [[#key-bindings][Key Bindings]]
  - [[#important-commands][Important commands]]
- [[#references][References]]

* Packages

Emacs facility to download and install "packages" that implement
additional features. You can find information about a specific package
by using =C-h P= that prompts for the name and shows more details.

There is a very detail package in Emacs help system that you can find
on [[info:emacs#Packages][info:emacs#Packages]]. 

I always start a new configuration setup with a naive mindset that I
will not install thousands of external packages, however they are so
good and make our life so much easier that is hard to avoid them
altogether.

Let's initialize the package system.
#+begin_src emacs-lisp
  (require 'package)

  (unless (bound-and-true-p package--initialized)
    (package-initialize))
#+end_src

Despite the fact that GNU Elpa, the standard repository, of Emacs
packages maintained by the core team already have many different
packages, I like to use another external repository called [[https://melpa.org/#/][Melpa]] which
is currently maintained by the community and curated by Purcell's and
his team.

#+begin_src emacs-lisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
#+end_src

We need to refresh the archives to make this change to take place.

#+begin_src emacs-lisp
  (unless (file-exists-p "~/.emacs.d/elpa/archives/melpa")
    (package-refresh-contents))
#+end_src

Also, by default Emacs also automatically loads all installed packages
in subsequent Emacs session. I want to disable it.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

When you have more than a dozen packages, it makes the process of
managing them very difficult without any additional help. And by my
experience the only real issue is due to performance because you will
inevitably have many external packages loaded in situations where you
don't need it. Fortunately, Jon Wiegley made our lives easier by
creating =use-package=, please look for =C-h P use-package= to more
details.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package)
    (package-install 'delight))

  (require 'use-package)
#+end_src

* Operating System

#+begin_src emacs-lisp
  (setenv "PATH" (concat (getenv "PATH") ":/home/wand/scripts"))
  (setq exec-path (append exec-path '("/home/wand/scripts")))

  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+end_src

I've been using qutebrowser as my main browser for more than one year
now. Idk, I like keyboard centric products.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
	browse-url-generic-program "qutebrowser")
#+END_SRC

Garbage collect on focus-out, Emacs should feel snappier.
#+BEGIN_SRC emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

Fix old security Emacs problems
#+BEGIN_SRC emacs-lisp
  (eval-after-load "enriched"
    '(defun enriched-decode-display-prop (start end &optional param)
       (list start end)))
#+END_SRC

Ease the font caching during GC.
#+begin_src emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+end_src

* Aesthetics

    Since I never use the mouse with GNU Emacs, I prefer not to use
    invasive graphical elements.
    #+begin_src emacs-lisp
      (when window-system
	(menu-bar-mode -1)
	(tool-bar-mode -1)
	(scroll-bar-mode -1)
	(tooltip-mode -1))
    #+end_src

    Enabling some builtin modes that are very helpful e.g. highlight
    the positions of open/close of parenthesis, prettify symbols for
    now basically converts a fn to a lambda symbol, but I intend to
    expand the list of converted symbols.

    #+begin_src emacs-lisp
      (show-paren-mode t)
      (global-prettify-symbols-mode t)
      (blink-cursor-mode 0)

      (use-package time
        :ensure nil
        :init
        (setq display-time-default-load-average nil
    	  display-time-format "%Hh%M"
    	  display-time-day-and-date t)
        :config
        (display-time-mode t))
    #+end_src

    #+begin_src emacs-lisp
      (use-package simple
        :ensure nil
        :delight auto-fill-mode
        :config
        (add-hook 'text-mode-hook #'auto-fill-mode))
    #+end_src

    The color theme is always a complicated matter. I've been trying
    several ones, most recently I had settle with Protesilaos
    =modus-{operandi,vivendi}= packages, but now I want to try =dakrone=
    for a while.

    #+BEGIN_SRC emacs-lisp
      (use-package dakrone-theme
        :ensure t
        :config
        (load-theme 'dakrone t))
    #+END_SRC

    I like the default font, but why not change it towards a more
    programming-friendlier one: Source Code Pro.

    #+begin_src emacs-lisp
      (defun bk/font-family-size (family size)
        "Set frame font to FAMILY at SIZE."
        (set-frame-font
         (concat family "-" (number-to-string size) ":hintstyle=hintfull") t t))

      (bk/font-family-size "Source Code Pro Medium" 12)
    #+end_src

    Let's remove some crunchy messages at startup time.
    #+begin_src emacs-lisp
      (setq inhibit-splash-screen t
    	use-file-dialog nil
    	use-dialog-box nil
    	inhibit-startup-echo-area-message t)
    #+end_src

    Control the fringe around the frame.
    #+BEGIN_SRC emacs-lisp
      (setq default-frame-alist
	    '((vertical-scroll-bars)
	      (left-fringe . 3)
	      (right-fringe . 0)
	      (buffer-predicate . exwm-layout--other-buffer-predicate)))
    #+END_SRC

* Defaults

    Does not clutter my =init.el= file with customized variables.
    #+begin_src emacs-lisp
      (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
      (when (file-exists-p custom-file)
        (load custom-file))
    #+end_src

    Show current key-sequence in minibuffer, like vim does. Any feedback
    after typing is better UX than no feedback at all.
    #+BEGIN_SRC emacs-lisp
      (setq echo-keystrokes 0.2)
    #+END_SRC

    Say you copied a link from your web browser, then switched to Emacs to
    paste it somewhere. Before you do that, you notice something you want
    to kill. Doing that will place the last kill to the clipboard, thus
    overriding the thing you copied earlier. We can have a kill ring
    solution:
    #+BEGIN_SRC emacs-lisp
      (setq save-interprogram-paste-before-kill t)
    #+END_SRC

    #+begin_src emacs-lisp
      (setq tab-always-indent 'complete)
      (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
      (setq custom-safe-themes t)

      (defalias 'cquit 'cider-quit)
      (defalias 'yes-or-no-p 'y-or-n-p)

      ;; built in htop
      (setq proced-auto-update-flag t
    	proced-auto-update-interval 1
    	proced-descend t)
    #+end_src

    Enable some built in modes to add critical functionality to
    Emacs. More explanation about them will follow in future.

    #+begin_src emacs-lisp
      (delete-selection-mode t)
      (pending-delete-mode t)
      (column-number-mode 1)
      (global-auto-revert-mode)
    #+end_src

    Save the buffers when you lose focus.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'focus-out-hook (lambda () (save-some-buffers t)))
    #+END_SRC

** Recentf

#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :init
    (setq recentf-max-saved-items 500
	  recentf-max-menu-items 15
	  recentf-show-file-shortcuts-flag nil
	  recentf-auto-cleanup 'never)
    :config
    (recentf-mode t))
#+end_src

** Extended Command

=smex= is an improved version of =extended-command= or =M-x=

#+begin_src emacs-lisp
  (use-package smex
    :ensure t
    :config
    (smex-initialize))
#+end_src

** Case switch

#+begin_src emacs-lisp
  (use-package fix-word
    :ensure t
    :config
    (global-set-key (kbd "M-u") #'fix-word-upcase)
    (global-set-key (kbd "M-l") #'fix-word-downcase)
    (global-set-key (kbd "M-c") #'fix-word-capitalize))
#+end_src

** Registers

Emacs registers are compartments where you can save text, rectangles,
positions, and other things for later use. Once you save text or a
rectangle in a register, you can copy it into the buffer once or many
times; once you save a position in a register, you can jump back to
that position once or many times.

For more information: `C-h r' and then letter *i* to search for
registers and the amazing video from [[https://youtu.be/u1YoF4ycLTY][Protesilaos]].

The prefix to all commands of registers is *C-x r*


| command             | description                         |
|---------------------+-------------------------------------|
| M-x view-register R | see what register R contains        |
| C-x r s             | save region to register             |
| C-x r i             | insert text from a register         |
| C-x r n             | record a number defaults to 0       |
| C-x r +             | increment a number from register    |
| C-x r SPC           | record a position into register     |
| C-x r j             | jump to positions or windows config |
| C-x r w             | save a window configuration         |
| C-x r f             | save a frame configuration          |


Important note: the data saved into the register is persistent as long
as you don't override it.

The way to specify a number, is to use an universal argument e.g.
*C-u <number> C-x n*


Clean all the registers you saved.
#+BEGIN_SRC emacs-lisp
  (defun bk/clear-registers ()
    "Remove all saved registers."
    (interactive)
    (setq register-alist nil))
#+END_SRC


#+begin_src emacs-lisp
  (set-register ?e '(file . "~/.emacs.d/init.el"))
  (set-register ?t '(file . "~/org/todo.org"))
  (set-register ?c '(file . "~/.emacs.d/docs/cheatsheet.org"))

#+end_src

** Abbreviation

#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :delight abbrev-mode
    :config
    (setq-default abbrev-mode t))

  (defun bk/add-region-local-abbrev (start end)
    "Go from START to END and add the selected text to a local abbrev."
    (interactive "r")
    (if (use-region-p)
	(let ((num-words (count-words-region start end)))
	  (add-mode-abbrev num-words)
	  (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a l") 'bk/add-region-local-abbrev)

  (defun bk/add-region-global-abbrev (start end)
    "Go from START to END and add the selected text to global abbrev."
    (interactive "r")
    (if (use-region-p)
	(let ((num-words (count-words-region start end)))
	  (add-abbrev global-abbrev-table "Global" num-words)
	  (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a g") 'bk/add-region-global-abbrev)
#+end_src

** Imenu

#+begin_src emacs-lisp
    ;;; imenu - produces menus for accessing locations in documents
  ;; for source-code buffer the locations to index are typically definitions
  ;; of functions, variables, and so on.
  (require 'imenu)

  (defun ido-menu--read (index-alist &optional prompt)
    "Show imenu INDEX-ALIST on ido interface as PROMPT."
    (let* ((symatpt (thing-at-point 'symbol))
	   (names (mapcar 'car index-alist))
	   (name (ido-completing-read (or prompt "imenu ") names
				      nil t nil nil nil))
	   (choice (assoc name index-alist)))
      (if (imenu--subalist-p choice)
	  (ido-menu--read (cdr choice) prompt nil)
	choice)))

  (defun bk/ido-menu ()
    "Public interface to my custom imenu through ido."
    (interactive)
    (let ((index-alist (cdr (imenu--make-index-alist))))
      (if (equal index-alist '(nil))
	  (message "No imenu tags in buffer")
	(imenu (ido-menu--read index-alist nil)))))

  (global-set-key (kbd "C-.") 'bk/ido-menu)

#+end_src

** Ibuffer

#+begin_src emacs-lisp

  (use-package ibuffer
    :ensure nil
    :init
    (setq ibuffer-expert t)
    (setq ibuffer-saved-filter-groups
	  '(("Main"
	     ("Directories" (mode . dired-mode))
	     ("Rest" (mode . restclient-mode))
	     ("Docker" (or
			(mode . docker-compose-mode)
			(mode . dockerfile-mode)))
	     ("Programming" (or
			     (mode . clojure-mode)
			     (mode . emacs-lisp-mode)
			     (mode . python-mode)))
	     ("Org" (mode . org-mode))
	     ("Markdown" (or
			  (mode . markdown-mode)
			  (mode . gfm-mode)))
	     ("Git" (or
		     (mode . magit-blame-mode)
		     (mode . magit-cherry-mode)
		     (mode . magit-diff-mode)
		     (mode . magit-log-mode)
		     (mode . magit-process-mode)
		     (mode . magit-status-mode)))
	     ("Emacs" (or
		       (name . "^\\*Help\\*$")
		       (name . "^\\*Custom.*")
		       (name . "^\\*Org Agenda\\*$")
		       (name . "^\\*info\\*$")
		       (name . "^\\*scratch\\*$")
		       (name . "^\\*Backtrace\\*$")
		       (name . "^\\*Messages\\*$"))))))
    :config
    (add-hook 'ibuffer-mode-hook (lambda ()
				   (ibuffer-switch-to-saved-filter-groups "Main"))))

  (use-package ibuffer-vc
    :ensure t
    :after ibuffer
    :config
    (define-key ibuffer-mode-map (kbd "/ V") 'ibuffer-vc-set-filter-groups-by-vc-root))
#+end_src

** Minibuffer

  The following setting prevent the minibuffer to grow, therefore it
  will be always 1 line height.

#+begin_src emacs-lisp
  (setq resize-mini-windows nil)
  (setq max-mini-window-height 1)
#+end_src

** Help

** Webjump

Provide a nice keyboard interface to web pages of your choosing.

Adding urban dictionary to webjump.
#+BEGIN_SRC emacs-lisp
  (eval-after-load "webjump"
    '(add-to-list 'webjump-sites '("Urban Dictionary" . [simple-query
							 "www.urbandictionary.com"
							 "http://www.urbandictionary.com/define.php?term="
							 ""])))

  (global-set-key (kbd "C-c j") 'webjump)
#+END_SRC

** Authentication Source

Auth Source is a generic interface for common backends such as your
operating sysetm's keychain and your local ~/.authinfo file. Auth
Source solves the problem of mapping passwords and usernames to hosts.

Debugging auth issues
#+BEGIN_SRC emacs-lisp
  (setq auth-source-debug t)
#+END_SRC

We need to tell auth-source where to look for secrets.
#+BEGIN_SRC emacs-lisp
  (setq auth-sources '((:source "~/.emacs.d/secrets/.authinfo")))
#+END_SRC

* Editing Text

#+begin_src emacs-lisp
  (use-package smart-shift
    :ensure t
    :config
    (global-smart-shift-mode t))
#+end_src

#+begin_src emacs-lisp
  (use-package change-inner :ensure t)
#+end_src

#+begin_src emacs-lisp
  (use-package expand-region :ensure t)
#+end_src

#+begin_src emacs-lisp 
  (use-package avy
    :ensure t
    :config
    (global-set-key (kbd "C-c ;") 'avy-goto-char))
#+end_src

#+begin_src emacs-lisp 
  (use-package eldoc
    :ensure nil
    :delight eldoc-mode)

  (use-package subword
    :ensure nil
    :delight subword-mode)
#+end_src

** Multiple Cursors

#+begin_src emacs-lisp 
  (use-package multiple-cursors :ensure t)

#+end_src

** Custom functions

#+begin_src emacs-lisp 
  ;; `C-a' first takes you to the first non-whitespace char as
  ;; `back-to-indentation' on a line, and if pressed again takes you to
  ;; the actual beginning of the line.
  (defun smarter-move-beginning-of-line (arg)
    "Move depending on ARG to beginning of visible line or not.
    From https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/."
    (interactive "^p")
    (setq arg (or arg 1))
    (when (/= arg 1)
      (let ((line-move-visual nil))
	(forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
	(move-beginning-of-line 1))))

  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
#+end_src

* Completions
** Minibuffer (ido mode)

Ido - interactive do - help us with switching between buffers, opening
files and directories with a minimum of keystrokes. As you type in a
substring, the list of buffers or files currently matching the
substring are displayed as you type.

There is an amazing [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Ido]] about Ido contains more details about how
to leverage its functionalities to improve your productivity.

#+begin_src emacs-lisp 
  (use-package ido
    :ensure nil
    :init (setq ido-use-virtual-buffers t
		ido-use-faces t
		ido-enable-flex-matching t
		ido-create-new-buffer 'always)
    :config
    (ido-mode t)
    (ido-everywhere t)
    :bind (:map ido-common-completion-map
		("M-e" . ido-edit-input)
		("M-r" . ido-toggle-regexp)))
#+end_src

More functionality

   1. After =C-x b=, the buffer at the head of the list can be killed
      by pressing =C-k=.
   2. After =C-x C-f=, you can delete (i.e. physically remove) the
      file at the head of the list with =C-k=


We can find a nice description of ido at the help page on [[help:ido][C-h P ido]].

** Company mode

Company is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

#+begin_src emacs-lisp 
  (use-package company
    :ensure t
    :delight company-mode
    :init
    (setq company-show-numbers t
	  company-tooltip-limit 10
	  company-minimum-prefix-length 2
	  company-tooltip-align-annotations t
	  company-transformers '(company-sort-by-occurrence)
	  company-idle-delay 0.5)
    :config
    (global-company-mode t))
#+end_src

If you are familiar with other IDE you should have noticed they
provide some documentation for the completion candidates. Fortunately,
there is a great package to provide it for company.

#+begin_src emacs-lisp 
  (use-package company-quickhelp
      :ensure t
      :after company
      :config
      (company-quickhelp-mode))
#+end_src
  
Also, we numbered all the candidates and the following code will
enable us to choose the candidate based on its number. This solution
was stolen from [[https://oremacs.com/2017/12/27/company-numbers/][link]] with some customization and simplification to
provide only what I saw useful.

#+begin_src emacs-lisp 
  (defun ora-company-number ()
    "Choose the candidate based on his number at candidate list."
    (interactive)
    (let* ((k (this-command-keys))
	   (re (concat "^" company-prefix k)))
      (if (cl-find-if (lambda (s) (string-match re s)) company-candidates)
	  (self-insert-command)
	(company-complete-number (string-to-number k)))))

  (defun ora-activate-number ()
    "Activate the number-based choices in company."
    (interactive)
    (let ((map company-active-map))
      (mapc
       (lambda (x)
	 (define-key map (format "%d" x) 'ora-company-number))
       (number-sequence 0 9))
      ;; (define-key map " " (lambda ()
      ;; 			  (interactive)
      ;; 			  (company-abort)
      ;; 			  (self-insert-command 1)))
      (define-key map (kbd "<return>") nil)))

  (eval-after-load 'company
    '(ora-activate-number))
#+end_src

* Window

    Ease the task of changing window quickly.

    #+begin_src emacs-lisp
      (use-package ace-window
        :ensure t
        :init
        (setq aw-keys '(?h ?j ?k ?l ?y ?u ?i ?o ?p)
    	  aw-background nil
    	  aw-scope 'frame
    	  aw-dispatch-alist
    	  '((?s aw-swap-window "swap window")
    	    (?2 aw-split-window-vert "split window vertically")
    	    (?3 aw-split-window-horz "split window horizontally")
    	    (?? aw-show-dispatch-help)))
        :config
        (ace-window-display-mode -1)
        (global-set-key (kbd "C-x o") 'ace-window))
    #+end_src

** Winner

Winner is a built-in tool that keeps a record of buffer and window
layout changes. It then allows us to move back and forth in the
history of said changes. The mnemonic is related to Emacs default
commands to operating on windows (C-x 4) and the undo operations with
[uU] letter. 

There are some buffers that winner will not restore, I list them in
the *winner-boring-buffers*.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure nil
    :hook (after-init . winner-mode)
    :init
    (setq winner-dont-bind-my-keys t)
    (setq winner-boring-buffers
	  '("*Completions*"
	    "*Compile-Log*"
	    "*inferior-lisp*"
	    "*Fuzzy Completions*"
	    "*Apropos*"
	    "*Help*"
	    "*cvs*"
	    "*Buffer List*"
	    "*Ibuffer*"
	    "*esh command on file*"))
    :bind (("C-x 4 u" . winner-undo)
	   ("C-x 4 U" . winner-redo)))
#+END_SRC

* Dired

    #+begin_src emacs-lisp
      (require 'dired-x)

      (setq dired-dwim-target t)

      (defun bk/dired-xdg-open ()
        "Open the file at point with xdg-open."
        (interactive)
        (let ((file (dired-get-filename nil t)))
          (message "Opening %s..." file)
          (call-process "xdg-open" nil 0 nil file)
          (message "Opening %s done" file)))

      (eval-after-load 'dired
        '(define-key dired-mode-map (kbd "O") 'bk/dired-xdg-open))
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (defun bk/dired-directories-first ()
	"Sort dired listings with directories first."
	(save-excursion
	  (let (buffer-read-only)
	    (forward-line 2)
	    (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
	  (set-buffer-modified-p nil)))

      (advice-add 'dired-readin :after #'bk/dired-directories-first)
    #+END_SRC

* TRAMP

  If TRAMP makes backup files, they should be better be kept locally
  than remote.
  #+BEGIN_SRC emacs-lisp
    (setq tramp-backup-directory-alist backup-directory-alist)
  #+END_SRC

* Linters

=Flycheck= is a modern on-the-fly syntax checking extension for GNU
Emacs, intended as replacement for the older Flymake.

#+begin_src emacs-lisp 
  (use-package flycheck
    :ensure t
    :init
    (setq flycheck-check-syntax-automatically '(mode-enabled save)
	  flycheck-display-errors-delay .3)
    :config
    (global-flycheck-mode))

  (use-package flycheck-clj-kondo :ensure t)
#+end_src

A very important command you should remember is =C-c ! v= or (=M-x
flycheck-verify-setup=) that can help you verify for your current mode
if everything is fine with your linter and it's backend.

The following package implements a minor-mode for displaying errors
from Flycheck right below their reporting location, using overlays.

#+begin_src emacs-lisp
  (use-package flycheck-inline
    :ensure t
    :after flycheck
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
#+end_src

Integrate [[Unified Modeling Language]] with flycheck to automatically
check the syntax of your plantuml files on the fly.

#+begin_src emacs-lisp
  (use-package flycheck-plantuml
    :ensure t
    :after flycheck
    :config
    (flycheck-plantuml-setup))
#+end_src

* Docker

#+begin_src emacs-lisp 
  (use-package docker
    :ensure t
    :bind
    ("C-c d" . docker))

  (use-package docker-tramp
    :ensure t)

  (use-package dockerfile-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
    (add-to-list 'auto-mode-alist '("DockerfileDev\\'" . dockerfile-mode)))

  (use-package docker-compose-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("docker-compose[^/]*\\.yml\\'" . docker-compose-mode)))

  (defun bk/dockerfile-add-build-args ()
    "Add env variables to your docker build."
    (interactive)
    (let* ((vars (read-from-minibuffer "sequence of <envName>=<envValue>: "))
	   (split-vars (split-string vars " ")))
      (setq dockerfile-build-args nil)
      (dolist (v split-vars)
	(add-to-list 'dockerfile-build-args v))
      (setq docker-build-history-args vars)))


  (defun bk/docker-compose-custom-envs ()
    "Add usual env variables to Emacs environment."
    (interactive)
    (let* ((idu (shell-command-to-string "id -u"))
	   (idg (shell-command-to-string "id -g"))
	   (uid (string-join (vector (string-trim idu) ":" (string-trim idg)))))
      (setenv "WEBSERVER_PORT" "3000")
      (setenv "CURRENT_UID" uid)
      (message "setenv WEBSERVER_PORT=3000 CURRENT_UID=$(id -u):$(id -g) done!")))

  (defun bk/docker-cleanup-buffers ()
    "Delete all the docker buffers created."
    (interactive)
    (kill-matching-buffers "docker" nil t))

#+end_src

* RSS Feed

I like to read about programming, but Emacs and Clojure are by far the
most interesting communities I know so far, therefore, my feeds have
many links from these subjects.

#+begin_src emacs-lisp 
  (use-package elfeed
    :ensure t
    :commands (elfeed elfeed-update)
    :config
    (setq-default elfeed-search-filter "@24-months-ago +unread")
    (setq elfeed-feeds
	  '(("http://lambda-the-ultimate.org/rss.xml" functional)
	    ("https://byorgey.wordpress.com/feed/" functional)
	    ("http://gigasquidsoftware.com/atom.xml" clojure)
	    ("http://swannodette.github.com/atom.xml" clojure)
	    ("https://rigsomelight.com/feed.xml" clojure)
	    ("https://lambdaisland.com/feeds/blog.atom" clojure)
	    ("https://nullprogram.com/feed/" programming)
	    ("http://feeds.feedburner.com/cognicast" clojure)
	    ("http://feeds2.feedburner.com/StuartSierra" clojure)
	    ("http://feeds.feedburner.com/Juxt" clojure)
	    ("http://blog.cognitect.com/blog?format=rss" clojure)
	    ("https://existentialtype.wordpress.com/feed/" functional)
	    ("http://insideclojure.org/feed.xml" clojure)
	    ("https://yogthos.net/feed.xml" clojure)
	    ("http://endlessparentheses.com/atom.xml" emacs)
	    ("http://www.blackhats.es/wordpress/?feed=rss2" emacs)
	    ("http://www.howardism.org/index.xml" emacs)
	    ("http://www.masteringemacs.org/feed/" emacs)
	    ("http://tonsky.me/blog/atom.xml" clojure)
	    ("http://www.clojure.net/rss.xml" clojure)
	    ("https://www.youtube.com/feeds/videos.xml?user=techguruuk" emacs)
	    ("http://emacsrocks.com/atom.xml" emacs)
	    ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
	    ("http://yqrashawn.com/feeds/lazyblorg-all.atom_1.0.links-only.xml" emacs))))

#+end_src

By default, s run a live filter and you can type something like "Xah"
to dynamically narrow the list of stories to those containing that
string. The only problem is that you need an extra whitespace before
the word, " Xah", let's fix that.

#+BEGIN_SRC emacs-lisp
  (defun bk/elfeed-search-live-filter-space ()
    "Insert space when running elfeed filter"
    (interactive)
    (let ((elfeed-search-filter (concat elfeed-search-filter " ")))
      (elfeed-search-live-filter)))

  (eval-after-load 'elfeed
    '(define-key elfeed-search-mode-map (kbd "/") 'bk/elfeed-search-live-filter-space))
#+END_SRC

* Slack

Slack from Emacs? :O Why not? I am having a terrible time configuring
all my workspaces lately. Therefore, it sounds like a perfect
opportunity to leverage the best tool for the job once again.

#+BEGIN_SRC emacs-lisp
  (use-package slack
    :ensure t
    :init
    (setq slack-buffer-emojify t
	  slack-prefer-current-team t
	  slack-buffer-function #'switch-to-buffer
	  slack-completing-read-function #'ido-completing-read
	  slack-display-team-name nil)
    :config
    (slack-register-team
     :name "captalysdev"
     :default t
     :token (auth-source-pick-first-password
	     :host "slack.com"
	     :user "captalysdev")
     :subscribed-channels '(onboarding geral dev)
     :full-and-display-names t)

    (slack-register-team
     :name "clojurians"
     :token (auth-source-pick-first-password
	     :host "slack.com"
	     :user "clojurians")
     :subscribed-channels '(beginners reitit))

    (slack-register-team
     :name "captalys-oficial"
     :token (auth-source-pick-first-password
	     :host "slack.com"
	     :user "captalys-oficial")
     :subscribed-channels '(devops)
     :full-and-display-names t))

#+END_SRC

Bring up the mentions menu with `@', and insert a space afterwards.
#+BEGIN_SRC emacs-lisp
  (define-key slack-mode-map "@"
    (defun endless/slack-message-embed-mention ()
      (interactive)
      (call-interactively #'slack-message-embed-mention)
      (insert " ")))
#+END_SRC


CRUD on messages
#+BEGIN_SRC emacs-lisp
  (define-key slack-mode-map (kbd "C-c C-d") #'slack-message-delete)
  (define-key slack-mode-map (kbd "C-c C-e") #'slack-message-edit)
  (define-key slack-mode-map (kbd "C-c C-k") #'slack-channel-leave)
#+END_SRC

Circe is a client for IRC in Emacs. It tries to have sane defaults,
and integrates well with the rest of the editor.

#+BEGIN_SRC emacs-lisp
  (use-package circe :ensure t)
#+END_SRC

Emojify is an Emacs extension to display emojis.
#+BEGIN_SRC emacs-lisp

  (use-package emojify :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package alert
    :commands (alert)
    :init
    (setq alert-default-style 'libnotify))
#+END_SRC


How to use Slack on emacs? Some terminology from the website:

| Function                   | Description                                                                        |
|----------------------------+------------------------------------------------------------------------------------|
| im                         | an IM (instant message) is a direct message between you and exactly one other user |
| channel                    | A channel is a slack channel which you are a member of                             |
| group                      | Any chat (direct message or channel) which isn't an IM is a group                  |
| slack-register-team        | set team configuration and create team                                             |
| slack-change-current-team  | change slack-current-team var                                                      |
| slack-start                | do authorize and initialze                                                         |
| slack-ws-close             | turn off websocket connection                                                      |
| slack-group-select         | select group from list                                                             |
| slack-im-select            | select direct message from list                                                    |
| slack-channel-select       | select channel from list                                                           |
| slack-group-list-update    | update group list                                                                  |
| slack-channel-list-update  | update channel list                                                                |
| slack-message-embed-mentio | use to mention to user                                                             |
| slack-file-upload          | uploads a file                                                                     |

* Spotify

  #+BEGIN_SRC emacs-lisp
    (use-package helm-spotify-plus
      :ensure t
      :config
      (global-set-key (kbd "C-c m s") 'helm-spotify-plus)
      (global-set-key (kbd "C-c m f") 'helm-spotify-plus-next)
      (global-set-key (kbd "C-c m b") 'helm-spotify-plus-previous)
      (global-set-key (kbd "C-c m p") 'helm-spotify-plus-play)
      (global-set-key (kbd "C-c m g") 'helm-spotify-plus-pause))
  #+END_SRC

* Rest client

#+begin_src emacs-lisp 
  (use-package restclient
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.restclient\\'" . restclient-mode)))

  (use-package company-restclient
    :ensure t
    :after company
    :config
    (add-to-list 'company-backends 'company-restclient))

#+end_src

* Version Control
** Magit

    #+begin_src emacs-lisp
      (use-package magit
        :ensure t
        :config
        (add-to-list 'magit-no-confirm 'stage-all-changes))
    #+end_src

** Time machine

    #+begin_src emacs-lisp
      (use-package git-timemachine :ensure t)
    #+end_src

** Aesthetics

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :ensure t
       :init
       (setq diff-hl-side 'left)
       :config
       (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
       (diff-hl-flydiff-mode +1)
       (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
       (global-diff-hl-mode +1))

     (custom-set-faces
      '(diff-hl-change ((t (:background "#3a81c3"))))
      '(diff-hl-insert ((t (:background "#7ccd7c"))))
      '(diff-hl-delete ((t (:background "#ee6363")))))
   #+END_SRC

** Miscellaneous

   #+BEGIN_SRC emacs-lisp
     (use-package browse-at-remote :ensure t)
     (use-package gitconfig-mode :ensure t)
     (use-package gitignore-templates :ensure t)

   #+END_SRC

* Unified Modeling Language

The UML is a general-purpose, developmental, modeling language in the
field of software engineering that is intended to provide a standard
way to visualize the design of a system.

   1. any activities (jobs)
   2. individual components of the system
   3. how the system will run
   4. how entities interact with others
   5. external user interfaces

The UML diagrams represent two different views of a system model

   - *Static* (or structural) view: emphasizes the static structure of
     the system using objects, attributes, operations and
     relationships. It includes class diagrams and composite structure
     diagrams.
   - *Dynamic* (or behavioral) view: emphasizes the dynamic behavior
     of the system by showing collaborations among objects and changes
     to the internal states of objects. This view includes sequence
     diagrams, activity diagrams and state machine diagrams.

Let's see a very interesting cheatsheet now:

  [[./images/uml-1.png]]

  [[./images/uml-2.png]]

  [[./images/uml-3.png]]


The internal setup in order to use it will happen though =PlantUML=
which has an specific syntax but is very easy to pick it up, follow
examples at the official documentation at [[https://plantuml.com/][webpage]].

#+begin_src emacs-lisp 
  (use-package plantuml-mode
    :ensure t
    :mode ("\\.plantuml\\'" "\\.puml\\'")
    :init
    (setq org-plantuml-jar-path "/home/wand/plantuml.jar")
    :config
    (require 'ob-plantuml))
#+end_src

* Search

** Wgrep

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep
       :ensure t)
   #+END_SRC

** Ripgrep

    #+BEGIN_SRC emacs-lisp
      (use-package rg
        :ensure t
        :config
        (rg-define-search bk/search-git-root-or-dir
          :query ask
          :format regexp
          :files "everything"
          :dir (let ((vc (vc-root-dir)))
    	     (if vc
    		 vc
    	       default-directory))
          :confirm prefix
          :flags ("--hidden -g !.git"))
        :bind
        ("M-s g" . bk/search-git-root-or-DIR))
    #+END_SRC

** Isearch

    You can invoke it using =C-s= and typing your desired search
    string. Also, if you want to use the regexp flavour you can use
    =M-C-s=.

    Run =C-h k C-s= yo get an /awesome/ help menu with all the extra
    keys you can use with =isearch=. These are the ones I use the
    most:

    | Keybindings                   | Description                                |
    |-------------------------------+--------------------------------------------|
    | C-s                           | search forward                             |
    | C-r                           | search backward                            |
    | M-C-s                         | search forward using regexp                |
    | M-C-r                         | search backward using regexp               |
    | C-s C-w                       | search word at point                       |
    | M-s                           | is a prefix while in isearch mode          |
    | (while isearch activated) M-r | turn your regular isearch into regexp mode |
    | M-s .                         | search for thing at point                  |
    | M-s o                         | get the results in occur buffer            |
    | M-s h r                       | highlight regexp                           |
    | M-s h u                       | undo the highlight                         |
    | C-s M-r                       | toggle regexp search                       |

* Shell

    #+begin_src emacs-lisp
      (use-package eshell-bookmark
        :ensure t
        :config
        (add-hook 'eshell-mode-hook 'eshell-bookmark-setup))

      (setenv "PAGER" "cat")

      (defun eshell-clear-buffer ()
        "Clear the terminal buffer."
        (interactive)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (eshell-send-input)))

      (add-hook 'eshell-mode-hook (lambda ()
    				(local-set-key (kbd "C-l") 'eshell-clear-buffer)))

    #+end_src

    #+begin_src emacs-lisp
      (require 'em-alias)
      (add-hook 'eshell-mode-hook
    	    (lambda ()
    	      (eshell/alias "e" "find-file $1")
    	      (eshell/alias "ee" "find-file-other-window $1")))
    #+end_src

* Json

#+begin_src emacs-lisp 
  (use-package json-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode)))
#+end_src

* General Programming 

Sometimes I place some TODO and FIXME words in the middle of my code
so I can come back to it latter and work on the subjects. The
following snippet will highlight these words to help me identify them.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (defun bk--add-watchwords ()
			      (font-lock-add-keywords
			       nil `(("\\<\\(FIX\\(ME\\))?\\|TODO\\)"
				      1 font-lock-warning-face t)))))
#+END_SRC

** Whitespaces

Control your whitespaces!

#+BEGIN_SRC emacs-lisp
  (require 'whitespace)
  (setq whitespace-style '(trailing lines space-before-tab
                    indentation space-after-tab))
  (setq whitespace-line-column 100)
  (whitespace-mode +1)
#+END_SRC

A less intrusive ‘delete-trailing-whitespaces’ on save.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :ensure t
    :diminish ws-butler-mode
    :config
    (ws-butler-global-mode +1))
#+END_SRC

* Markdown

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :ensure t
        :config
        (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
        (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
        (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'markdown-mode
	'(progn
	   ;; `pandoc' is better than obsolete `markdown'
	   (when (executable-find "pandoc")
	     (setq markdown-command "pandoc -f markdown"))))
    #+END_SRC

* Notes

  #+BEGIN_SRC emacs-lisp
    (use-package deft
      :ensure t
      :config
      (setq deft-default-extension "org"
	    deft-use-filename-as-title nil
	    deft-use-filter-string-for-filename t
	    deft-file-naming-rules '((noslash . "-")
				     (nospace . "-")
				     (case-fn . downcase))
	    deft-extensions '("txt" "org")
	    deft-directory "~/notes"
	    deft-auto-save-interval 0
	    deft-text-mode 'org-mode
	    deft-recursive t))
  #+END_SRC

* PDF

PDF Tools is, among other things, a replacement of DocView for PDF
files. The key difference is that pages are not pre-rendered by
e.g. ghostscript and stored in the file-system, but rather created
on-demand and stored in memory.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :defer 1
    :magic ("%PDF" . pdf-view-mode)
    :init (pdf-tools-install :no-query))

  (use-package pdf-view
    :ensure nil
    :after pdf-tools
    :bind (:map pdf-view-mode-map
		("C-s" . isearch-forward)
		("d" . pdf-annot-delete)
		("h" . pdf-annot-add-highlight-markup-annotation)
		("t" . pdf-annot-add-text-annotation))
    :custom
    (pdf-view-display-size 'fit-page)
    (pdf-view-resize-factor 1.1)
    (pdf-view-use-unicode-ligther nil))
#+end_src

* Latex

#+BEGIN_SRC emacs-lisp 
  (use-package tex-site
    :ensure auctex
    :config
    (require 'latex)
    (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
          TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view))
          TeX-source-correlate-start-server t)

    ;; to refresh the buffer after compilation
    (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer))
#+END_SRC


#+BEGIN_SRC emacs-lisp 
  (use-package reftex
    :ensure t
    :config
    (setq reftex-cite-prompt-optional-args t))

  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-save-query nil
        TeX-PDF-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp 
  (add-hook 'LaTeX-mode-hook 'visual-line-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'Latex-math-mode)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

  (with-eval-after-load 'tex
    (add-to-list 'safe-local-variable-values
                 '(TeX-command-extra-options . "-shell-escape")))
#+END_SRC

* Clojure

Unfortunately, Emacs does not have a builtin major mode for Clojure,
however we have a great community that support any programming
language available in the world as a major mode of emacs rsrs.

The intent of a major mode is basically provide font-lock,
indentation, navigation and refactoring for the target programming
language.

At the =clojure-mode= website recommends us to use the MELBA Stable
bundle because the MELPA version is following a development branch of
the library. As this mode is very important for me right now, I would
like to stick to the more stable branch.

#+begin_src emacs-lisp 
  (use-package clojure-mode
    :ensure t
    :diminish (clojure-mode "λ")
    :init
    (setq clojure-align-forms-automatically t)
    :config
    (add-hook 'clojure-mode-hook 'smartparens-strict-mode)
    (add-hook 'clojure-mode-hook 'eldoc-mode)
    (add-hook 'clojure-mode-hook 'subword-mode))
#+end_src

The previous setting =clojure-align-forms-automatically= makes the
following example a default behavior and you don't need to manually
align the values. **NOTE**: this is an experiment, 90% of the time
this happened to me, that was the default behavior I wanted. Let's see
how much the other 10% will annoy me now.

#+BEGIN_SRC clojure 
  (def my-map
    {:a-key 1
     :other-key 2})

  ;; after C-c SPC
  (def my-map
    {:a-key     1
     :other-key 2})
#+END_SRC


There are several incredible examples of refactoring in the
[[https://github.com/clojure-emacs/clojure-mode][clojure-mode]] website. 

   1. TODO: Study refactoring support in clojure-mode.


Provides additional refactoring support, but as we see from the
=clojure-mode= github page, all these extra functionalities are
migrating to the clojure mode package.

#+begin_src emacs-lisp 
  (use-package clj-refactor
    :ensure t
    :delight clj-refactor-mode
    :after (clojure-mode)
    :init
    (setq cljr-magic-require-namespaces '(("io" . "clojure.java.io")
					  ("set" . "clojure.set")
					  ("walk" . "clojure.walk")
					  ("zip" . "clojure.zip")
					  ("time" . "clj-time.core")
					  ("log" . "clojure.tools.logging")
					  ("json" . "cheshire.core")
					  ("client" . "org.httpkit.client")
					  ("http" . "clj-http.core")
					  ("a" . "clojure.core.async")
					  ("jdbc" . "next.jdbc")
					  ("s" . "clojure.spec.alpha")
					  ("gen" . "clojure.spec.gen.alpha")))
    :config
    (add-hook 'clojure-mode-hook (lambda ()
				   (clj-refactor-mode t)
				   (cljr-add-keybindings-with-prefix "C-c C-m"))))
#+end_src


We also improved the font-locking for built-in methods and macros of
clojure.

#+begin_src emacs-lisp 
  (use-package clojure-mode-extra-font-locking
    :ensure t
    :after (clojure-mode))
#+end_src

Now comes the real deal for Clojure development, CIDER extends Emacs
with support for interactive programming in Clojure. It basically
connects the buffer to a nREPL and communicate back-and-forth to
provide functionalities such as code completion, documentation,
navigation, debugging, running tests, and many more.

   1. TODO:  Study cider mode


#+begin_src emacs-lisp 
  (use-package cider
    :ensure t
    :after (clojure-mode)
    :config
    (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion))
#+end_src

When cider is not connected, I usually use some commands that makes no
sense in =clojure-mode= and receive a non-sense error message that I
never understand what is happening or even worse it just hands without
no feedback.

I will borrow the idea from Alex Baranosky and create a dummy function
to provide some useful feedback message to my future self.

#+begin_src emacs-lisp 
  (defun bk/nrepl-warn-when-not-connected ()
    (interactive)
    (message "Oops! You're not connected to an nREPL server. Please run M-x cider or M-x cider-jack-in to connect"))
#+end_src

And bind this to the most common keys that requires cider activated.

#+begin_src emacs-lisp 
  (define-key clojure-mode-map (kbd "C-x C-e") 'bk/nrepl-warn-when-not-connected)
  (define-key clojure-mode-map (kbd "C-c C-k") 'bk/nrepl-warn-when-not-connected)
  (define-key clojure-mode-map (kbd "C-c C-z") 'bk/nrepl-warn-when-not-connected)
#+end_src


Often I need to fire a repl and investigate some properties better, I
have a =temp= project setup in my machine a simple =lein new temp=
where I have some libraries already in the =project.clj= dependency
available. The following function helps me get there quickly and
require some frequent namespaces.

#+begin_src emacs-lisp 
  (defun bk/repl ()
    "Start an interactive repl in a temp project"
    (interactive)
    (cider-jack-in '(:project-dir "/home/wand/temp"))
    (add-hook 'cider-connected-hook
	      (lambda ()
		(cider-repl-set-ns "user")
		(cider-nrepl-sync-request:eval "(require '[clj-time.core :as t])")
		(cider-nrepl-sync-request:eval "(require '[clj-http.core :as client])")
		(cider-nrepl-sync-request:eval "(require '[org.httpkit.client :as http])")
		(cider-nrepl-sync-request:eval "(require '[clojure.core.async :as a])")
		(cider-nrepl-sync-request:eval "(require '[cheshire.core :as json])"))))
#+end_src

  Let's make a nice usage of =babashka= scripting for clojure and
  print a random doc-string message in the initial of my Emacs
  session.
  #+begin_src emacs-lisp 
    (let ((clj-docstring (shell-command-to-string "docstring.clj")))
      (when clj-docstring
	(setq initial-scratch-message clj-docstring)))
  #+end_src

  The =docstring.clj= content is pretty small and it required [[https://github.com/borkdude/babashka][babashka]]
  to be installed, the content:

  #+BEGIN_SRC clojure
    #!/usr/bin/env bb

    (require '[clojure.repl])

    (defmacro random-doc []
      (let [sym (-> (ns-publics 'clojure.core) keys rand-nth)]
	(if (:doc (meta (resolve sym)))
	  `(clojure.repl/doc ~sym)
	  `(random-doc))))

    (random-doc)
  #+END_SRC

  I added the new file to my PATH variable. That's all.

  #+begin_src emacs-lisp 
    (defun bk/clj-random-docstring ()
      "Random doc-string into new buffer."
      (interactive)
      (let ((docstring (shell-command-to-string "docstring.clj"))
	    (buffer-name "*Clojure Random Docs*"))
	(when (get-buffer buffer-name)
	  (kill-buffer buffer-name))
	(get-buffer-create buffer-name)
	(with-current-buffer buffer-name (insert docstring))
	(switch-to-buffer-other-window buffer-name)
	(special-mode)))
  #+end_src


Clojure rocks!

* Python

  #+BEGIN_SRC emacs-lisp
    (use-package elpy
      :ensure t
      :config
      (elpy-enable)
      (pyvenv-activate "~/miniconda3")
      (delete `elpy-module-django elpy-modules)
      (delete `elpy-module-highlight-indentation elpy-modules))

    (use-package py-autopep8
      :ensure t
      :init
      (setq py-autopep8-options '("--max-line-length=250"))
      :config
      (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
  #+END_SRC

* SQL

#+begin_src emacs-lisp
  (use-package sqlup-mode
    :ensure t
    :config
    (add-hook 'sql-mode-hook 'sqlup-mode)
    (add-hook 'sql-interactive-hook 'sqlup-mode)
    (add-to-list 'sqlup-blacklist "name"))
#+end_src

This Emacs library provides commands and a minor mode for easily
reformating SQL using external programs such as pgformatter which can
be installed in Arch Linux using =yaourt -S pgformatter-git=

#+begin_src emacs-lisp
  (use-package sqlformat
    :ensure t
    :init
    (setq sqlformat-command 'pgformatter
	  sqlformat-args '("-s2" "-g"))
    :config
    (add-hook 'sql-mode-hook 'sqlformat-on-save-mode))
#+end_src

Indentation is also important

#+begin_src emacs-lisp
  (use-package sql-indent
    :ensure t
    :delight sql-mode "Σ "
    :after (:any sql sql-interactive-mode)
    :config
    (add-hook 'sql-mode-hook 'sqlind-minor-mode))
#+end_src

* Parenthesis

#+begin_src emacs-lisp 
  (use-package smartparens
    :ensure t
    :delight smartparens-strict-mode
    :init
    (setq sp-highlight-pair-overlay nil)
    :config
    (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
    (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)

    (with-eval-after-load "smartparens"
      ;; remove some pairs
      (sp-pair "'" nil :actions :rem)
      (sp-pair "`" nil :actions :rem)

      ;; include new wrap of pairs
      (sp-pair "(" ")" :wrap "M-(")
      (sp-pair "[" "]" :wrap "M-[")

      (sp-use-smartparens-bindings)		;enable default smartparens bindings

      (sp-local-tag 'markdown-mode "c" "```clojure" "```")
      (sp-local-tag 'markdown-mode "e" "```elisp" "```")
      (sp-local-tag 'markdown-mode "b" "```bash" "```")
      (sp-local-tag 'markdown-mode "p" "```python" "```")

      (define-key smartparens-mode-map (kbd "M-p") 'sp-prefix-pair-object)))
#+end_src

* Org mode

When using =RET= over a link, please go to it.

#+begin_src emacs-lisp 
  (setq org-return-follows-link t)
#+end_src

Please, disable =flycheck= from org-src buffers. We always have errors
in there related to some emacs-lisp checkers. Here is how to disable
it.

#+begin_src emacs-lisp 
  (defun disable-flycheck-in-org-src-block ()
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

  (add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-block)
#+end_src

#+begin_src emacs-lisp 
  (use-package toc-org
    :ensure t
    :config
    (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src

I need to control the window that pops up when I open the Org Src
buffer to edit code.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

#+begin_src emacs-lisp 
  (require 'org-capture)
  (setq org-directory "/home/wand/org")
  (setq org-confirm-babel-evaluate nil)
  (setq org-agenda-files (list "/home/wand/org/todo.org"))
  (setq org-todo-keywords '((sequence "TODO(t)" "|" "DOING(d)" "|" "DONE(D)" "|" "CANCELLED(C)")
			    (sequence "STUDY(s)" "|" "STUDIED(S)")
			    (sequence "ACT(a)" "|" "ACTED(A)")))
  (setq org-capture-templates
	'(("c" "Capture some concise actionable item and exist" entry
	   (file+headline "todo.org" "Task list without a defined date")
	   "* TODO [#B] %^{Title}\n :PROPERTIES:\n :CAPTURED: %U\n :END:\n\n %i %l" :immediate-finish t)
	  ("t" "Task of importance with a tag, deadline, and further editable space" entry
	   (file+headline "todo.org" "Task list with a date")
	   "* %^{Scope of task||TODO [#A]|STUDY [#A]|Act on} %^{Title} %^g\n DEADLINE: %^t\n :PROPERTIES:\n :CONTEXT: %a\n:CAPTURED: %U\n :END:\n\n %i %?")))

  (setq org-agenda-window-setup 'only-window)

  ;;; after calling the `org-todo', the org mode tries to store some
  ;;; sort of a "note" using `org-store-log-note' function. I want that
  ;;; every modification done in my todo file save the file right after.
  (advice-add 'org-deadline :after (lambda (&rest _rest)
				     (org-save-all-org-buffers)))
  (advice-add 'org-schedule :after (lambda (&rest _rest)
				     (org-save-all-org-buffers)))
  (advice-add 'org-todo :after (lambda (&rest _rest)
				 (org-save-all-org-buffers)))
  (advice-add 'org-store-log-note :after (lambda (&rest _rest)
					   (org-save-all-org-buffers)))

#+end_src

** Reveal.js

*** TODO More details from how to build one presentation using the package
There an exhaustive documentation about Reveal.js in the github
[[https://gitlab.com/oer/org-re-reveal][repository]], please follow the link if more is necessary.

#+begin_src emacs-lisp
  (use-package org-re-reveal
    :ensure t
    :after org
    :custom
    (org-reveal-mathjax t)
    (org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"))
#+end_src

* Projects

#+begin_src emacs-lisp 
  (use-package projectile
    :ensure t
    :delight '(:eval (concat " " (projectile-project-name)))
    :init
    (setq projectile-completion-system 'ido)
    :config
    (projectile-mode t)
    :bind-keymap
    ("C-c p" . projectile-command-map))

#+end_src

* Spelling

#+begin_src emacs-lisp 
  (defun bk/spell-buffer-pt-BR ()
    "Spell check in portuguese."
    (interactive)
    (ispell-change-dictionary "pt_BR")
    (flyspell-buffer))

  (defun bk/spell-buffer-en ()
    "Spell check in english."
    (interactive)
    (ispell-change-dictionary "en_US")
    (flyspell-buffer))

  (use-package flyspell
    :ensure nil
    :delight flyspell-mode
    :config
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+end_src

* Snippets

#+begin_src emacs-lisp 
  (use-package yasnippet
    :ensure t
    :delight yas-minor-mode
    :config
    (yas-global-mode +1)
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "C-c y") #'yas-expand))
#+end_src

#+begin_src emacs-lisp 
  (use-package yasnippet-snippets :ensure t)
#+end_src

* Pomodoro

#+begin_src emacs-lisp 
  (use-package tomatinho
    :ensure t
    :bind
    ("<f10>" . tomatinho))
#+end_src

* General custom functions

#+begin_src emacs-lisp 
  (defvar url-http-end-of-headers)
  (defun bk/ip ()
    "Find my current public IP address."
    (interactive)
    (let* ((endpoint "https://api.ipify.org")
	   (myip (with-current-buffer (url-retrieve-synchronously endpoint)
		   (buffer-substring (+ 1 url-http-end-of-headers) (point-max)))))
      (kill-new myip)
      (message "IP: %s" myip)))
#+end_src


#+BEGIN_SRC emacs-lisp 
  (defun bk/sudo-edit (&optional arg)
    "Function to edit file with super-user with optional ARG."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:" (read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (defun bk/kill-buffer-and-file (buffer-name)
    "Removes file connected to current buffer and kills buffer."
    (interactive "bKill buffer and its file:")
    (let* ((buffer (get-buffer buffer-name))
	   (filename (buffer-file-name buffer)))
      (if (not (and filename (file-exists-p filename)))
	  (error "Buffer '%s' is not visiting a file!" buffer-name)
	(delete-file filename)
	(kill-buffer buffer))))
#+END_SRC

* Keys

#+begin_src emacs-lisp 
  (use-package which-key
    :ensure t
    :delight which-key-mode
    :config
    (which-key-mode))
#+end_src

#+begin_src emacs-lisp
  (global-set-key "\C-x3" (lambda ()
			    (interactive)
			    (split-window-horizontally)
			    (other-window 1)))

  (global-set-key "\C-x2" (lambda ()
			    (interactive)
			    (split-window-vertically)
			    (other-window 1)))

  (global-set-key (kbd "C-x C-m") 'smex)
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-i") 'change-inner)
  (global-set-key (kbd "M-o") 'change-outer)
  (global-set-key (kbd "C-c e") 'eshell)
  (global-set-key (kbd "C-c g s") 'magit-status)
  (global-set-key (kbd "C-c C-k") 'eval-buffer)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "C-c t") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-=") 'er/expand-region)
  (global-set-key (kbd "C-x p") 'pop-to-mark-command)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

#+end_src

* Emacs as my own Operating System

#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :init
    (setq use-dialog-box nil
	  exwm-workspace-number 2)
    (setq exwm-input-simulation-keys
	  '(([?\C-p] . [up])
	    ([?\C-n] . [down])
	    ([?\C-f] . [right])
	    ([?\C-b] . [left])
	    ([?\C-s] . [\C-f])
	    ([?\s-w] . [\C-f4])
	    ([?\s-v] . [\C-v])
	    ;; cut/paste
	    ([?\M-w] . [\C-c])
	    ([?\C-y] . [\C-v])
	    ([?\C-w] . [\C-x])))
    :config
    (display-battery-mode t)

    (require 'exwm)
    (require 'exwm-config)
    (exwm-config-default)

    (exwm-input-set-simulation-keys exwm-input-simulation-keys)

    ;; universal Get-me-outta-here
    (push ?\C-g exwm-input-prefix-keys)
    (exwm-input-set-key (kbd "C-g") #'keyboard-quit)

    (require 'exwm-randr)
    (setq exwm-randr-workspace-output-plist '(1 "HDMI1" 2 "eDP1"))
    (add-hook 'exwm-randr-screen-change-hook
	      (lambda ()
		(start-process-shell-command
		 "xrandr" nil "xrandr --output eDP1 --mode 1600x900 --pos 0x0 --rotate normal --output DP1 --off --output DP2 --off --output HDMI1 --primary --mode 1680x1050 --pos 1600x0 --rotate normal --output HDMI2 --off --output VIRTUAL1 --off")))
    (exwm-randr-enable))
#+END_SRC

   Now that I am using Emacs as my window manager I can use the meta keys
   to provide operations over the windows itself, in other days, there
   were reserved to i3wm operations.

   #+BEGIN_SRC emacs-lisp
     (exwm-input-set-key (kbd "s-x") #'exwm-input-toggle-keyboard)
     (exwm-input-set-key (kbd "s-h") #'windmove-left)
     (exwm-input-set-key (kbd "s-j") #'windmove-down)
     (exwm-input-set-key (kbd "s-k") #'windmove-up)
     (exwm-input-set-key (kbd "s-l") #'windmove-right)
   #+END_SRC

   Ease the possibility of switching between workspace
   #+BEGIN_SRC emacs-lisp
     (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)

     (dotimes (i 10)
       (exwm-input-set-key (kbd (format "s-%d" i))
			   `(lambda ()
			      (interactive)
			      (exwm-workspace-switch-create ,i))))
   #+END_SRC

   Ag has a very nice package to help us out in EXWM, the feature is
   similar in usage to Org-SRC-Blocks, therefore you press =C-c '= on
   input text boxes of other external apps and another window pops up so
   you can have all the Emacs under the finger while editing.

   #+BEGIN_SRC emacs-lisp
     (use-package exwm-edit
       :ensure t
       :after (exwm)
       :config
       (exwm-input-set-key (kbd "s-e") #'exwm-edit--compose))
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (use-package dmenu
       :ensure t
       :commands (dmenu))
   #+END_SRC

   I made a change in =qutebrowser= so every tab open is a new window of
   qutebrowser, therefore I can search for the tabs using =C-x b= from
   Emacs.

   =:set -t tabs.tabs_are_window true=

   More settings for qutebrowser can be found [[https://www.qutebrowser.org/doc/help/settings.html][here]].

   Disabling floating window
   #+BEGIN_SRC emacs-lisp
     (setq exwm-manage-force-tiling t)
   #+END_SRC
** Buffers

   Rename buffers to match the X11 window class or title:
   #+BEGIN_SRC emacs-lisp
     (defun exwm-rename-buffer ()
       (interactive)
       (exwm-workspace-rename-buffer
	(concat exwm-class-name ":"
		(if (<= (length exwm-title) 50) exwm-title
		  (concat (substring exwm-title 0 49))))))

     (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
     (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)

   #+END_SRC

** Key Bindings

   "Global key bindings" in EXWM work essentially anywhere, including
   buffers that are currently in char mode. The bindings below should
   be fairly straightforward.
   #+BEGIN_SRC emacs-lisp
     (defun bk/keepmenu ()
       "Call password manager."
       (interactive)
       (start-process-shell-command "pwd" nil "keepmenu"))

     (defun bk/lock-screen ()
       (interactive)
       (start-process-shell-command "lock" nil "xscreensaver-command -lock"))

     (defun bk/qutebrowse ()
       (interactive)
       (start-process-shell-command "browser" nil "qutebrowser"))

     (use-package emacs
       :ensure nil
       :config
       (setq exwm-input-global-keys
	     `(([?\s-r] . exwm-reset)
	       ([?\s-d] . dmenu)
	       ([?\s-p] . bk/keepmenu)
	       ([?\s-l] . bk/lock-screen))))
   #+END_SRC

   Regular keys to control audio using the package pulseaudio.
   #+BEGIN_SRC emacs-lisp
     (use-package pulseaudio-control
       :ensure t
       :after (exwm)
       :config
       (exwm-input-set-key
	(kbd "<XF86AudioLowerVolume>")
	#'pulseaudio-control-decrease-volume)

       (exwm-input-set-key
	(kbd "<XF86AudioRaiseVolume>")
	#'pulseaudio-control-increase-volume)

       (exwm-input-set-key
	(kbd "<XF86AudioMute>")
	#'pulseaudio-control-toggle-current-sink-mute))
   #+END_SRC

   Control the backlight level
   #+BEGIN_SRC emacs-lisp
     (use-package emacs
       :ensure nil
       :after (exwm)
       :config
       (exwm-input-set-key
	(kbd "<XF86MonBrightnessDown>")
	(lambda () (interactive)
	  (start-process-shell-command "bdown" nil "xbacklight -dec 10")))

       (exwm-input-set-key
	(kbd "<XF86MonBrightnessUp>")
	(lambda () (interactive)
	  (start-process-shell-command "bdown" nil "xbacklight -inc 10"))))
   #+END_SRC

   More binding definitions
   #+BEGIN_SRC emacs-lisp
     (defun bk/qutebrowser ()
       "Open the browser"
       (interactive)
       (start-process-shell-command "brw" nil "qutebrowser"))

     (defun bk/fix-caps-and-key-rate ()
       "Capslock is another ctrl and key rate need to be higher"
       (interactive)
       (start-process-shell-command "caps" nil "setxkbmap -option ctrl:nocaps")
       (start-process-shell-command "krate" nil "xset r rate 300 50")
       (message "Ctrl and key rate fixed!"))

     (use-package emacs
       :ensure nil
       :after (exwm)
       :config
       (exwm-input-set-key (kbd "s-q") #'bk/qutebrowser)
       (exwm-input-set-key (kbd "C-c k") #'bk/fix-caps-and-key-rate))
   #+END_SRC

   Print screens are way to serious business.
   #+BEGIN_SRC emacs-lisp
     (defun bk/print-from-region ()
       "Print screen interactively."
       (interactive)
       (start-process-shell-command "pt" nil "scrot -s -e 'mv $f /home/wand/Pictures/'"))

     (exwm-input-set-key (kbd "<print>") #'bk/print-from-region)
   #+END_SRC

   System tray
   #+BEGIN_SRC emacs-lisp
     (defun exwm-bk/nm-applet ()
       (interactive)
       (start-process-shell-command "applt" nil
				    "nm-applet"))

     (defun exwm-bk/bluetooth ()
       (interactive)
       (start-process-shell-command "bl-applt" nil
				    "blueman-applet"))

     (defun exwm-bk/xscreensaver ()
       (interactive)
       (start-process-shell-command "xs" nil
				    "xscreensaver -no-splash"))

     (defun exwm-bk/key-rate ()
       (interactive)
       (start-process-shell-command "key-rate" nil
				    "xset r rate 300 50"))

     (defun exwm-bk/nocaps ()
       (interactive)
       (start-process-shell-command "nocaps" nil
				    "setxkbmap -option ctrl:nocaps"))

     (use-package exwm-systemtray
       :ensure nil
       :after (exwm)
       :init
       (setq exwm-systemtray-height 16)
       :config
       (exwm-systemtray-enable)
       (add-hook 'exwm-init-hook 'exwm-bk/nm-applet t)
       (add-hook 'exwm-init-hook 'exwm-bk/bluetooth t)
       (add-hook 'exwm-init-hook 'exwm-bk/xscreensaver)
       (add-hook 'exwm-init-hook 'exwm-bk/key-rate)
       (add-hook 'exwm-init-hook 'exwm-bk/nocaps))
   #+END_SRC

** Important commands

   | Keys | Command                    | Description                                 |
   |------+----------------------------+---------------------------------------------|
   | -    | exwm-workspace-move-window | send current window to a specific workspace |

* References

   1. [[https://github.com/ch11ng/exwm/wiki][EXWM User Guide]]
   2. [[https://github.com/bvk/config/blob/master/emacs/wm.el][EXWM config with support for external monitor]]
   3. [[https://www.reddit.com/r/emacs/comments/6huok9/exwm_configs/][Reddit EXWM Configs?]]
   4. [[https://github.com/agzam/dot-spacemacs/tree/master/layers/ag-exwm][Ag layer for EXWM]]
   5. [[https://github.com/kinleyd/configs/blob/master/init.el][Another great emacs.d focusing on EXWM]]
   6. [[https://www.reddit.com/r/emacs/comments/74hetz/emacs_everywhere/][Emacs Everywhere]] - by u/ambrevar. Very nice post on reddit.
   7. https://ambrevar.xyz/emacs/
   8. [[https://github.com/wasamasa/dotemacs/blob/master/init.org][Literate emacs ]] - by wasamasa
